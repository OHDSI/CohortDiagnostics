# Copyright 2021 Observational Health Data Sciences and Informatics
#
# This file is part of CohortDiagnostics
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

makeBackwardsCompatible <-
  function(cohorts, forceWebApiCohortId = FALSE) {
    # make sure there is a column called 'name' - used for finding sql in package
    if ('atlasId' %in% colnames(cohorts)) {
      cohorts <- cohorts %>%
        dplyr::mutate(atlasId = as.double(.data$atlasId))
    }
    if ('cohortId' %in% colnames(cohorts)) {
      cohorts <- cohorts %>%
        dplyr::mutate(cohortId = as.double(.data$cohortId))
    }
    if ('id' %in% colnames(cohorts)) {
      cohorts <- cohorts %>%
        dplyr::mutate(id = as.double(.data$id))
    }
    if ('webApiCohortId' %in% colnames(cohorts)) {
      cohorts <- cohorts %>%
        dplyr::mutate(webApiCohortId = as.double(.data$webApiCohortId))
    }
    if (!"name" %in% colnames(cohorts)) {
      # id/cohortId takes precedence over webapiId/atlasId
      if ('id' %in% colnames(cohorts)) {
        if (typeof(cohorts$id) %in% c('integer', 'double')) {
          cohorts <- cohorts %>%
            dplyr::mutate(name = as.character(.data$id)) %>%
            dplyr::mutate(cohortId = .data$id)
        }
      } else if ('cohortId' %in% colnames(cohorts)) {
        if (typeof(cohorts$cohortId) %in% c('integer', 'double')) {
          cohorts <- cohorts %>%
            dplyr::mutate(name = as.character(.data$cohortId)) %>%
            dplyr::mutate(cohortId = .data$cohortId)
        }
      } else if ('webApiCohortId' %in% colnames(cohorts)) {
        if (typeof(cohorts$webApiCohortId) %in% c('integer', 'double')) {
          cohorts <- cohorts %>%
            dplyr::mutate(name = as.character(.data$webApiCohortId)) %>%
            dplyr::mutate(cohortId = .data$webApiCohortId)
        }
      } else if ('atlasId' %in% colnames(cohorts)) {
        if (typeof(cohorts$atlasId) %in% c('integer', 'double')) {
          cohorts <- cohorts %>%
            dplyr::mutate(name = as.character(.data$atlasId)) %>%
            dplyr::mutate(cohortId = .data$atlasId)
        }
      }
    }
    
    if (!'webApiCohortId' %in% colnames(cohorts)) {
      if ('atlasId' %in% colnames(cohorts)) {
        if (typeof(cohorts$atlasId) %in% c('integer', 'double')) {
          cohorts <- cohorts  %>%
            dplyr::mutate(atlasId = as.double(.data$atlasId)) %>%
            dplyr::mutate(webApiCohortId = .data$atlasId)
        }
      } else if ('cohortId' %in% colnames(cohorts)) {
        if (typeof(cohorts$cohortId) %in% c('integer', 'double')) {
          cohorts <- cohorts %>%
            dplyr::mutate(webApiCohortId = as.double(.data$cohortId))
        }
      } else if (all(
        'name' %in% colnames(cohorts),
        typeof(strtoi(cohorts$name)) %in% c('integer', 'double'),
        strtoi(cohorts$name),
        forceWebApiCohortId
      )) {
        warning('webapiCohortId not found. Forcing..')
        cohorts <- cohorts %>%
          dplyr::mutate(webApiCohortId = as.double(strtoi(cohorts$name)))
        #webApiCohortId should always be integer/double
      }
    }
    
    # make sure there is a column called 'cohortName' - use to identify a cohort
    if (!'cohortName' %in% colnames(cohorts)) {
      if ('atlasName' %in% colnames(cohorts)) {
        cohorts <- cohorts %>%
          dplyr::mutate(cohortName = as.character(.data$atlasName))
      } else if ('id' %in% colnames(cohorts)) {
        cohorts <- cohorts %>%
          dplyr::mutate(cohortName = as.character(.data$id))
      } else if ('webApiCohortId' %in% colnames(cohorts)) {
        cohorts <- cohorts %>%
          dplyr::mutate(cohortName = as.character(.data$webApiCohortId))
      } else if ('atlasId' %in% colnames(cohorts)) {
        cohorts <- cohorts %>%
          dplyr::mutate(cohortName = as.character(.data$atlasId))
      }
    }
    
    # make sure there is a column called 'cohortId'
    if (!'cohortId' %in% colnames(cohorts)) {
      if (typeof(cohorts$name) %in% c('integer', 'double')) {
        cohorts <- cohorts %>%
          dplyr::mutate(cohortId = as.double(.data$name))
      }
    }
    
    # make sure there is a column called 'atlasId'
    if (!'atlasId' %in% colnames(cohorts)) {
      if (typeof(cohorts$webApiCohortId) %in% c('integer', 'double')) {
        cohorts <- cohorts %>%
          dplyr::mutate(atlasId = as.double(.data$webApiCohortId))
      }
    }
    
    if ('atlasId' %in% colnames(cohorts)) {
      cohorts <- cohorts %>%
        dplyr::mutate(atlasId = as.double(.data$atlasId))
    }
    if ('cohortId' %in% colnames(cohorts)) {
      cohorts <- cohorts %>%
        dplyr::mutate(cohortId = as.double(.data$cohortId))
    }
    if ('id' %in% colnames(cohorts)) {
      cohorts <- cohorts %>%
        dplyr::mutate(id = as.double(.data$id))
    }
    if ('webApiCohortId' %in% colnames(cohorts)) {
      cohorts <- cohorts %>%
        dplyr::mutate(webApiCohortId = as.double(.data$webApiCohortId))
    }
    return(cohorts)
  }

getCohortsJsonAndSqlFromPackage <-
  function(packageName = packageName,
           cohortToCreateFile = cohortToCreateFile,
           cohortIds = NULL,
           errorMessage = NULL) {
    ParallelLogger::logDebug(" - Executing on cohorts specified in package - ", packageName)
    
    if (is.null(errorMessage) |
        !class(errorMessage) == 'AssertColection') {
      errorMessage <- checkmate::makeAssertCollection()
    }
    checkmate::assertCharacter(
      x = packageName,
      min.len = 1,
      max.len = 1,
      add = errorMessage
    )
    pathToCsv <-
      system.file(cohortToCreateFile, package = packageName)
    checkmate::assertFileExists(
      x = system.file(cohortToCreateFile, package = packageName),
      access = "r",
      extension = "csv",
      add = errorMessage
    )
    
    checkInputFileEncoding(pathToCsv)
    
    cohorts <- readr::read_csv(pathToCsv,
                               col_types = readr::cols(),
                               guess_max = min(1e7))
    
    cohorts <-
      makeBackwardsCompatible(cohorts, forceWebApiCohortId = FALSE)
    if (!is.null(cohortIds)) {
      cohorts <- cohorts %>%
        dplyr::filter(.data$cohortId %in% cohortIds)
    }
    
    checkmate::reportAssertions(collection = errorMessage)
    
    getSql <- function(name) {
      pathToSql <-
        system.file("sql", "sql_server", paste0(name, ".sql"), package = packageName)
      checkmate::assertFile(
        x = pathToSql,
        access = "r",
        extension = ".sql",
        add = errorMessage
      )
      sql <- readChar(pathToSql, file.info(pathToSql)$size)
      return(sql)
    }
    cohorts$sql <- sapply(cohorts$name, getSql)
    getJson <- function(name) {
      pathToJson <-
        system.file("cohorts", paste0(name, ".json"), package = packageName)
      checkmate::assertFile(
        x = pathToJson,
        access = "r",
        extension = ".sql",
        add = errorMessage
      )
      json <- readChar(pathToJson, file.info(pathToJson)$size)
      return(json)
    }
    cohorts$json <- sapply(cohorts$name, getJson)
    return(cohorts)
  }


getCohortsJsonAndSqlFromWebApi <- function(baseUrl = baseUrl,
                                           cohortSetReference = cohortSetReference,
                                           cohortIds = NULL,
                                           errorMessage = NULL,
                                           generateStats = TRUE) {
  ParallelLogger::logDebug(" - Running Cohort Diagnostics on cohort specified in WebApi - ",
                           baseUrl)
  
  if (is.null(errorMessage) |
      !class(errorMessage) == 'AssertColection') {
    errorMessage <- checkmate::makeAssertCollection()
  }
  checkmate::assertCharacter(x = baseUrl,
                             min.chars = 1,
                             add = errorMessage)
  webApiVersion <- ROhdsiWebApi::getWebApiVersion(baseUrl)
  ParallelLogger::logInfo("  - WebApi of version ", webApiVersion, " found at ", baseUrl)
  checkmate::assertCharacter(x = webApiVersion,
                             min.chars = 1,
                             add = errorMessage)
  checkmate::reportAssertions(collection = errorMessage)
  if (!is.null(cohortIds)) {
    cohortSetReference <- cohortSetReference %>%
      dplyr::filter(.data$cohortId %in% cohortIds)
  }
  
  cohortSetReference$json <- ""
  cohortSetReference$sql <- ""
  
  ParallelLogger::logInfo("  - Retrieving cohort definitions from WebAPI")
  if (nrow(cohortSetReference) == 0) {
    stop(paste0("Provided cohortIds not found in WebApi. Aborting.."))
  }
  
  for (i in 1:nrow(cohortSetReference)) {
    ParallelLogger::logInfo("  - Retrieving definitions for cohort ",
                            cohortSetReference$cohortName[i])
    cohortDefinition <-
      ROhdsiWebApi::getCohortDefinition(cohortId = cohortSetReference$webApiCohortId[i],
                                        baseUrl = baseUrl)
    cohortSetReference$json[i] <-
      RJSONIO::toJSON(x = cohortDefinition$expression, digits = 23)
    cohortSetReference$sql[i] <-
      ROhdsiWebApi::getCohortSql(
        cohortDefinition = cohortDefinition,
        baseUrl = baseUrl,
        generateStats = generateStats
      )
  }
  return(cohortSetReference)
}

getCohortsJsonAndSql <- function(packageName = NULL,
                                 cohortToCreateFile = "settings/CohortsToCreate.csv",
                                 baseUrl = NULL,
                                 cohortSetReference = NULL,
                                 cohortIds = NULL,
                                 generateStats = TRUE) {
  if (!is.null(packageName)) {
    cohorts <-
      getCohortsJsonAndSqlFromPackage(
        packageName = packageName,
        cohortToCreateFile = cohortToCreateFile,
        cohortIds = cohortIds
      )
  } else {
    cohorts <- getCohortsJsonAndSqlFromWebApi(
      baseUrl = baseUrl,
      cohortSetReference = cohortSetReference,
      cohortIds = cohortIds,
      generateStats = generateStats
    )
  }
  if (nrow(cohorts) == 0) {
    return(NULL)
  }
  if (nrow(cohorts) != length(cohorts$cohortId %>% unique())) {
    warning(
      " - Please check input cohort specification. Is there duplication of cohortId? Exiting."
    )
    return(NULL)
  }
  return(cohorts)
}

createCohortTable <- function(connectionDetails = NULL,
                              connection = NULL,
                              cohortDatabaseSchema,
                              cohortTable = "cohort") {
  start <- Sys.time()
  ParallelLogger::logInfo("   - Note: Creating cohort table.")
  if (is.null(connection)) {
    connection <- DatabaseConnector::connect(connectionDetails)
    on.exit(DatabaseConnector::disconnect(connection))
  }
  sql <- SqlRender::loadRenderTranslateSql(
    "CreateCohortTable.sql",
    packageName = "CohortDiagnostics",
    dbms = connection@dbms,
    cohort_database_schema = cohortDatabaseSchema,
    cohort_table = cohortTable
  )
  DatabaseConnector::executeSql(connection,
                                sql,
                                progressBar = FALSE,
                                reportOverallTime = FALSE)
  ParallelLogger::logDebug(" - Created table ", cohortDatabaseSchema, ".", cohortTable)
  
  delta <- Sys.time() - start
  ParallelLogger::logTrace(paste(
    " - Creating cohort table took",
    signif(delta, 3),
    attr(delta, "units")
  ))
}

getInclusionStatisticsFromFiles <- function(cohortIds = NULL,
                                            folder,
                                            cohortInclusionFile = file.path(folder,
                                                                            "cohortInclusion.csv"),
                                            cohortInclusionResultFile = file.path(folder,
                                                                                  "cohortIncResult.csv"),
                                            cohortInclusionStatsFile = file.path(folder,
                                                                                 "cohortIncStats.csv"),
                                            cohortSummaryStatsFile = file.path(folder,
                                                                               "cohortSummaryStats.csv")) {
  start <- Sys.time()
  
  if (!file.exists(cohortInclusionFile)) {
    return(NULL)
  }
  
  fetchStats <- function(file) {
    ParallelLogger::logDebug("  - Fetching data from ", file)
    stats <- readr::read_csv(file,
                             col_types = readr::cols(),
                             guess_max = min(1e7))
    if (!is.null(cohortIds)) {
      stats <- stats %>%
        dplyr::filter(.data$cohortDefinitionId %in% cohortIds) %>%
        dplyr::rename(cohortId = .data$cohortDefinitionId)
    }
    return(stats)
  }
  
  inclusion <- fetchStats(cohortInclusionFile)
  if ('description' %in% colnames(inclusion)) {
    inclusion <-
      inclusion %>% tidyr::replace_na(replace = list(description = ''))
  } else {
    inclusion$description <- ''
  }
  
  summaryStats <- fetchStats(cohortSummaryStatsFile)
  inclusionStats <- fetchStats(cohortInclusionStatsFile)
  inclusionResults <- fetchStats(cohortInclusionResultFile)
  inclusionRuleStats <- dplyr::tibble(
    ruleSequenceId = 0,
    ruleName = '',
    meetSubjects = 0,
    gainSubjects = 0,
    totalSubjects = 0,
    remainSubjects = 0,
    cohortId = 0,
    databaseId = ''
  )[0,]
  
  for (cohortId in unique(inclusion$cohortId)) {
    cohortResult <-
      simplifyInclusionStats(
        inclusion = inclusion %>% dplyr::filter(.data$cohortId == cohortId),
        inclusionResults = inclusionResults %>% filter(.data$cohortId == cohortId),
        inclusionStats = inclusionStats %>% filter(.data$cohortId == cohortId)
      )
    cohortResult$cohortId <- cohortId
    inclusionRuleStats <- dplyr::bind_rows(inclusionRuleStats, cohortResult)
  }
  delta <- Sys.time() - start
  ParallelLogger::logTrace(paste(
    "Fetching inclusion statistics took",
    signif(delta, 3),
    attr(delta, "units")
  ))
  output <- list(
    inclusion_rule_stats = inclusionRuleStats,
    cohort_inclusion = inclusion,
    cohort_inclusion_result = inclusionResults,
    cohort_inclusion_stats = inclusionStats,
    cohort_summary_stats = summaryStats
  )
  return(output)
}

simplifyInclusionStats <- function(inclusion,
                                   inclusionResults,
                                   inclusionStats) {
  if (nrow(inclusion) == 0 ||
      nrow(inclusionStats) == 0) {
    return(dplyr::tibble())
  }
  
  result <- inclusion %>%
    dplyr::select(.data$ruleSequence, .data$name) %>%
    dplyr::distinct() %>%
    dplyr::inner_join(
      inclusionStats %>%
        dplyr::filter(.data$modeId == 0) %>%
        dplyr::select(
          .data$ruleSequence,
          .data$personCount,
          .data$gainCount,
          .data$personTotal
        ),
      by = "ruleSequence"
    ) %>%
    dplyr::mutate(remain = 0)
  
  inclusionResults <- inclusionResults %>%
    dplyr::filter(.data$modeId == 0)
  mask <- 0
  for (ruleId in 0:(nrow(result) - 1)) {
    mask <- bitwOr(mask, 2 ^ ruleId)
    idx <-
      bitwAnd(inclusionResults$inclusionRuleMask, mask) == mask
    result$remain[result$ruleSequence == ruleId] <-
      sum(inclusionResults$personCount[idx])
  }
  colnames(result) <- c(
    "ruleSequenceId",
    "ruleName",
    "meetSubjects",
    "gainSubjects",
    "totalSubjects",
    "remainSubjects"
  )
  return(result)
}

#' Instantiate a set of cohort(s)
#'
#' @description
#' This function instantiates a set of cohort(s) in specified cohort table, using definitions that are fetched from a WebApi interface.
#' Optionally, the inclusion rule statistics are computed and stored in the \code{inclusionStatisticsFolder}.
#'
#' @template Connection
#'
#' @template CohortTable
#'
#' @template TempEmulationSchema
#'
#' @template OracleTempSchema
#'
#' @template CdmDatabaseSchema
#'
#' @template VocabularyDatabaseSchema
#'
#' @template CohortSetSpecs
#'
#' @template CohortSetReference
#'
#' @param cohortIds                   Optionally, provide a subset of cohort IDs to restrict the
#'                                    construction to.
#' @param generateInclusionStats      Compute and store inclusion rule statistics?
#' @param inclusionStatisticsFolder   The folder where the inclusion rule statistics are stored. Can be
#'                                    left NULL if \code{generateInclusionStats = FALSE}.
#' @param createCohortTable           Create the cohort table? If \code{incremental = TRUE} and the table
#'                                    already exists this will be skipped.
#' @param incremental                 Create only cohorts that haven't been created before?
#' @param incrementalFolder           If \code{incremental = TRUE}, specify a folder where records are kept
#'                                    of which definition has been executed.
#' @return
#' A data frame with cohort counts
#'
#' @export
instantiateCohortSet <- function(connectionDetails = NULL,
                                 connection = NULL,
                                 cdmDatabaseSchema,
                                 vocabularyDatabaseSchema = cdmDatabaseSchema,
                                 tempEmulationSchema = NULL,
                                 oracleTempSchema = NULL,
                                 cohortDatabaseSchema = cdmDatabaseSchema,
                                 cohortTable = "cohort",
                                 cohortIds = NULL,
                                 packageName = NULL,
                                 cohortToCreateFile = "settings/CohortsToCreate.csv",
                                 baseUrl = NULL,
                                 cohortSetReference = NULL,
                                 generateInclusionStats = FALSE,
                                 inclusionStatisticsFolder = NULL,
                                 createCohortTable = TRUE,
                                 incremental = FALSE,
                                 incrementalFolder = NULL) {
  start <- Sys.time()
  ParallelLogger::logInfo("Cohort Instantiation started at ", start, '...')
  
  if (!is.null(cohortSetReference)) {
    ParallelLogger::logInfo(" - Found cohortSetReference. Cohort Diagnostics is running in WebApi mode.")
    cohortToCreateFile <- NULL
    if (all(
      is.null(dim(cohortSetReference)),
      length(cohortSetReference) > 0,
      typeof(cohortSetReference) %in% c('double', 'integer')
    )) {
      ParallelLogger::logInfo(
        ' - cohortSetReference found to be a vector of ids, instead of a data frame. Attempting to use it. Continuing.'
      )
      cohortSetReference <- dplyr::tibble(id = cohortSetReference)
    }
    cohortSetReference <-
      makeBackwardsCompatible(cohortSetReference, forceWebApiCohortId = TRUE)
  }
  
  if (!is.null(oracleTempSchema) && is.null(tempEmulationSchema)) {
    tempEmulationSchema <- oracleTempSchema
    warning(' - OracleTempSchema has been deprecated by DatabaseConnector')
  }
  
  if (generateInclusionStats) {
    if (is.null(inclusionStatisticsFolder)) {
      stop(" - Inclusion rule file folder not specified when generateInclusionStats = TRUE.")
    }
    if (!file.exists(inclusionStatisticsFolder)) {
      dir.create(inclusionStatisticsFolder, recursive = TRUE)
    }
  }
  if (incremental) {
    if (is.null(incrementalFolder)) {
      stop(" - Incremental folder not specified while in incremental mode.")
    }
    if (!file.exists(incrementalFolder)) {
      dir.create(incrementalFolder, recursive = TRUE)
    }
  }
  
  if (is.null(connection)) {
    connection <- DatabaseConnector::connect(connectionDetails)
    on.exit(DatabaseConnector::disconnect(connection))
  }
  
  cohorts <- getCohortsJsonAndSql(
    packageName = packageName,
    cohortToCreateFile = cohortToCreateFile,
    baseUrl = baseUrl,
    cohortSetReference = cohortSetReference,
    cohortIds = cohortIds,
    generateStats = generateInclusionStats
  )
  
  if (any(is.null(cohorts),
          nrow(cohorts) == 0)) {
    stop("Cohort definitions not found for provided cohort ids. Please check. Aborting.")
  }
  ParallelLogger::logInfo(" - Number of cohorts to instantiate: ", nrow(cohorts))
  
  if (createCohortTable) {
    needToCreate <- TRUE
    if (incremental) {
      tables <-
        DatabaseConnector::getTableNames(connection, cohortDatabaseSchema)
      if (toupper(cohortTable) %in% toupper(tables)) {
        ParallelLogger::logInfo(
          "   - Note: Cohort table already exists. Running in incremental mode. Re-using cohort table."
        )
        needToCreate <- FALSE
      }
    }
    if (needToCreate) {
      createCohortTable(
        connection = connection,
        cohortDatabaseSchema = cohortDatabaseSchema,
        cohortTable = cohortTable
      )
    }
  }
  
  if (incremental) {
    cohorts$checksum <- computeChecksum(cohorts$sql)
    recordKeepingFile <-
      file.path(incrementalFolder, "InstantiatedCohorts.csv")
  }
  
  if (generateInclusionStats) {
    createTempInclusionStatsTables(connection, tempEmulationSchema, cohorts)
  }
  
  instantiatedCohortIds <- c()
  ParallelLogger::logInfo(" - Instantiating:")
  for (i in 1:nrow(cohorts)) {
    if (!incremental || isTaskRequired(
      cohortId = cohorts$cohortId[i],
      checksum = cohorts$checksum[i],
      recordKeepingFile = recordKeepingFile
    )) {
      ParallelLogger::logInfo(
        "    (",
        scales::comma(i),
        "/",
        scales::comma(nrow(cohorts)),
        ") '",
        cohorts$cohortName[i],
        "' (",
        cohorts$cohortId[i],
        ")"
      )
      sql <- cohorts$sql[i]
      .warnMismatchSqlInclusionStats(sql, generateInclusionStats = generateInclusionStats)
      sql <- SqlRender::render(
        sql,
        cdm_database_schema = cdmDatabaseSchema,
        target_database_schema = cohortDatabaseSchema,
        target_cohort_table = cohortTable,
        target_cohort_id = cohorts$cohortId[i]
      )
      if (stringr::str_detect(string = sql,
                              pattern = 'vocabulary_database_schema')) {
        sql <- SqlRender::render(sql,
                                 vocabulary_database_schema = vocabularyDatabaseSchema)
      } else {
        ParallelLogger::logDebug(
          '- Cohort id ',
          cohorts$cohortId[i],
          " SQL does not have vocabularyDatabaseSchema."
        )
      }
      if (!stringr::str_detect(string = sql,
                               pattern = 'results_database_schema')) {
        ParallelLogger::logDebug('- Cohort id ',
                                 cohorts$cohortId[i],
                                 " SQL does not have resultsDatabaseSchema.")
      }
      if (generateInclusionStats) {
        if (stringr::str_detect(string = sql,
                                pattern = 'cohort_inclusion')) {
          sql <- SqlRender::render(
            sql,
            results_database_schema.cohort_inclusion = "#cohort_inclusion",
            results_database_schema.cohort_inclusion_result = "#cohort_inc_result",
            results_database_schema.cohort_inclusion_stats = "#cohort_inc_stats",
            results_database_schema.cohort_summary_stats = "#cohort_summary_stats"
          )
        } else {
          ParallelLogger::logDebug(
            ' - Cohort id ',
            cohorts$cohortId[i],
            " SQL does not have inclusion rule statistics tables."
          )
        }
        # added for compatibility for 2.8.1
        # https://github.com/OHDSI/CohortDiagnostics/issues/387
        # this table was introduced in v2.8.1, and does not exist in prior version of webapi
        if (stringr::str_detect(string = sql,
                                pattern = 'cohort_censor_stats')) {
          sql <- SqlRender::render(
            sql = sql,
            results_database_schema.cohort_censor_stats = "#cohort_censor_stats"
          )
        }
      } else {
        ParallelLogger::logDebug(
          " - Skipping inclusion rules for cohort id ",
          cohorts$cohortId[i],
          " because this diagnostics is set to FALSE."
        )
      }
      sql <- SqlRender::translate(sql,
                                  targetDialect = connection@dbms,
                                  tempEmulationSchema = tempEmulationSchema)
      DatabaseConnector::executeSql(
        connection = connection,
        sql = sql,
        reportOverallTime = FALSE,
        progressBar = FALSE
      )
      instantiatedCohortIds <-
        c(instantiatedCohortIds, cohorts$cohortId[i])
    }
  }
  
  if (generateInclusionStats) {
    saveAndDropTempInclusionStatsTables(
      connection = connection,
      tempEmulationSchema = tempEmulationSchema,
      inclusionStatisticsFolder = inclusionStatisticsFolder,
      incremental = incremental,
      cohortIds = instantiatedCohortIds
    )
  }
  if (incremental) {
    recordTasksDone(
      cohortId = cohorts$cohortId,
      checksum = cohorts$checksum,
      recordKeepingFile = recordKeepingFile
    )
  }
  
  delta <- Sys.time() - start
  writeLines(paste(
    " - Instantiating cohort set took",
    signif(delta, 3),
    attr(delta, "units")
  ))
}

createTempInclusionStatsTables <-
  function(connection, tempEmulationSchema, cohorts) {
    ParallelLogger::logTrace(" - Creating temporary inclusion statistics tables")
    sql <-
      SqlRender::loadRenderTranslateSql(
        "inclusionStatsTables.sql",
        packageName = "CohortDiagnostics",
        dbms = connection@dbms,
        tempEmulationSchema = tempEmulationSchema
      )
    DatabaseConnector::executeSql(connection,
                                  sql,
                                  progressBar = FALSE,
                                  reportOverallTime = FALSE)
    
    inclusionRules <- dplyr::tibble()
    for (i in 1:nrow(cohorts)) {
      cohortDefinition <-
        RJSONIO::fromJSON(content = cohorts$json[i], digits = 23)
      if (!is.null(cohortDefinition$InclusionRules)) {
        nrOfRules <- length(cohortDefinition$InclusionRules)
        if (nrOfRules > 0) {
          for (j in 1:nrOfRules) {
            ruleName <- cohortDefinition$InclusionRules[[j]]$name
            if (length(ruleName) == 0) {
              ruleName <- paste0(" -- Unamed rule (Sequence ", j - 1, ")")
            }
            inclusionRules <- dplyr::bind_rows(
              inclusionRules,
              tidyr::tibble(
                cohortId = cohorts$cohortId[i],
                ruleSequence = j - 1,
                ruleName = !!ruleName
              )
            ) %>%
              dplyr::distinct()
          }
        }
      }
    }
    
    if (nrow(inclusionRules) > 0) {
      inclusionRules <- inclusionRules %>%
        dplyr::inner_join(cohorts %>% dplyr::select(.data$cohortId, .data$cohortName),
                          by = "cohortId") %>%
        dplyr::rename(name = .data$ruleName,
                      cohortDefinitionId = .data$cohortId) %>%
        dplyr::select(.data$cohortDefinitionId, .data$ruleSequence, .data$name)
      
      DatabaseConnector::insertTable(
        connection = connection,
        tableName = "#cohort_inclusion",
        data = inclusionRules,
        dropTableIfExists = TRUE,
        createTable = TRUE,
        tempTable = TRUE,
        tempEmulationSchema = tempEmulationSchema,
        camelCaseToSnakeCase = TRUE
      )
    } else {
      inclusionRules <- dplyr::tibble(
        cohortDefinitionId = as.double(),
        ruleSequence = as.integer(),
        name = as.character()
      )
      DatabaseConnector::insertTable(
        connection = connection,
        tableName = "#cohort_inclusion",
        data = inclusionRules,
        dropTableIfExists = TRUE,
        createTable = TRUE,
        tempTable = TRUE,
        tempEmulationSchema = tempEmulationSchema,
        camelCaseToSnakeCase = TRUE
      )
    }
  }

saveAndDropTempInclusionStatsTables <- function(connection,
                                                tempEmulationSchema,
                                                inclusionStatisticsFolder,
                                                incremental,
                                                cohortIds) {
  fetchStats <- function(table, fileName) {
    ParallelLogger::logDebug(" - Fetching data from ", table)
    sql <- "SELECT * FROM @table"
    data <- renderTranslateQuerySql(
      sql = sql,
      connection = connection,
      tempEmulationSchema = tempEmulationSchema,
      snakeCaseToCamelCase = TRUE,
      table = table
    )
    fullFileName <- file.path(inclusionStatisticsFolder, fileName)
    if (incremental) {
      saveIncremental(data = data,
                      fileName = fullFileName,
                      cohortId = cohortIds)
    } else {
      readr::write_excel_csv(
        x = data,
        file = fullFileName,
        na = "",
        append = FALSE
      )
    }
  }
  fetchStats("#cohort_inclusion", "cohortInclusion.csv")
  fetchStats("#cohort_inc_result", "cohortIncResult.csv")
  fetchStats("#cohort_inc_stats", "cohortIncStats.csv")
  fetchStats("#cohort_summary_stats", "cohortSummaryStats.csv")
  
  sql <- "TRUNCATE TABLE #cohort_inclusion;
    DROP TABLE #cohort_inclusion;

    TRUNCATE TABLE #cohort_inc_result;
    DROP TABLE #cohort_inc_result;

    TRUNCATE TABLE #cohort_inc_stats;
    DROP TABLE #cohort_inc_stats;

    TRUNCATE TABLE #cohort_summary_stats;
    DROP TABLE #cohort_summary_stats;"
  DatabaseConnector::renderTranslateExecuteSql(
    connection = connection,
    sql = sql,
    progressBar = FALSE,
    reportOverallTime = FALSE,
    tempEmulationSchema = tempEmulationSchema
  )
}

.warnMismatchSqlInclusionStats <-
  function(sql, generateInclusionStats) {
    if (any(
      stringr::str_detect(string = sql, pattern = "_inclusion_result"),
      stringr::str_detect(string = sql, pattern = "_inclusion_stats"),
      stringr::str_detect(string = sql, pattern = "_summary_stats"),
      stringr::str_detect(string = sql, pattern = "_censor_stats")
    )) {
      if (isFALSE(generateInclusionStats)) {
        warning(
          " - The cohort SQL was designed to output cohort inclusion statistics.
              But, generateInclusionStats is set to False while instantiating cohort.
              This may cause error and terminate cohort diagnositcs."
        )
      }
    } else {
      if (isTRUE(generateInclusionStats)) {
        warning(
          " - The cohort SQL was designed to NOT output cohort inclusion statistics.
              But, generateInclusionStats is set to TRUE while instantiating cohort.
              This may cause error and terminate cohort diagnositcs."
        )
      }
    }
  }
