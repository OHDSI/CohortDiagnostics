library(CohortDiagnostics)
library(testthat)

if (dir.exists(Sys.getenv("DATABASECONNECTOR_JAR_FOLDER"))) {
  jdbcDriverFolder <- Sys.getenv("DATABASECONNECTOR_JAR_FOLDER")
} else {
  jdbcDriverFolder <- tempfile("jdbcDrivers")
  dir.create(jdbcDriverFolder, showWarnings = FALSE)
  DatabaseConnector::downloadJdbcDrivers("postgresql", pathToDriver = jdbcDriverFolder)
  
  withr::defer({
    unlink(jdbcDriverFolder, recursive = TRUE, force = TRUE)
  }, testthat::teardown_env())
}

#' utility function to make sure connection is closed after usage
with_dbc_connection <- function(connection, code) {
  on.exit({
    DatabaseConnector::disconnect(connection)
  })
  eval(substitute(code), envir = connection, enclos = parent.frame())
}

connectionDetails <- DatabaseConnector::createConnectionDetails(
  dbms = "postgresql",
  user = Sys.getenv("CDM5_POSTGRESQL_USER"),
  password = URLdecode(Sys.getenv("CDM5_POSTGRESQL_PASSWORD")),
  server = Sys.getenv("CDM5_POSTGRESQL_SERVER"),
  pathToDriver = jdbcDriverFolder
)

cdmDatabaseSchema <- Sys.getenv("CDM5_POSTGRESQL_CDM_SCHEMA")
vocabularyDatabaseSchema <- Sys.getenv("CDM5_POSTGRESQL_CDM_SCHEMA")
cohortDiagnosticsSchema <- "cohort_diagnostics"
resultsDatabaseSchema <- paste0("r", 
                                as.character(gsub("[: -]", "" , Sys.time(), perl=TRUE)),
                                as.character(sample(1:100, 1)))
tempEmulationSchema <- NULL
cohortTable <- "cohort"
folder <- tempfile("cohortDiagnosticsTest")

withr::defer({
  connection <- DatabaseConnector::connect(connectionDetails = connectionDetails)
  dropSchemaIfExists <- paste0("DROP SCHEMA IF EXISTS ", resultsDatabaseSchema, " CASCADE;")
  DatabaseConnector::renderTranslateExecuteSql(sql = dropSchemaIfExists,
                                               connection = connection)

  DatabaseConnector::disconnect(connection)
  unlink(folder, recursive = TRUE, force = TRUE)
}, testthat::teardown_env())


#' Only works with postgres > 9.4
.tableExists <- function(connection, schema, tableName) {
  return(!is.na(
    DatabaseConnector::renderTranslateQuerySql(
      connection,
      "SELECT to_regclass('@schema.@table');",
      table = tableName,
      schema = schema
    )
  )[[1]])
}


test_that("Create schema", {
  connection <- DatabaseConnector::connect(connectionDetails = connectionDetails)
  with_dbc_connection(connection, {
    dropSchemaIfExists <- paste0("DROP SCHEMA IF EXISTS ", resultsDatabaseSchema, " CASCADE; CREATE SCHEMA ", resultsDatabaseSchema,";")
    DatabaseConnector::renderTranslateExecuteSql(sql = dropSchemaIfExists,
                                                 connection = connection)
    createResultsDataModel(connectionDetails = connectionDetails,
                           schema = resultsDatabaseSchema)

    specifications <- getResultsDataModelSpecifications()

    for (tableName in unique(specifications$tableName)) {
      expect_true(.tableExists(connection, resultsDatabaseSchema, tableName))
    }
    # Bad schema name
    expect_error(createResultsDataModel(connection = connection,
                                        schema = "non_existant_schema"))
  })
})


test_that("Results upload", {

  cohortDefinitionSet <- loadCohortsFromPackage(
    packageName = "CohortDiagnostics",
    cohortToCreateFile = "settings/CohortsToCreateForTesting.csv",
    cohortIds = c(17492, 17692)
  )
  inclusionStatsFolder <- file.path(folder, "incStats")
  instantiateCohortSet(
    connectionDetails = connectionDetails,
    cdmDatabaseSchema = cdmDatabaseSchema,
    vocabularyDatabaseSchema = vocabularyDatabaseSchema,
    tempEmulationSchema = tempEmulationSchema,
    cohortDatabaseSchema = cohortDiagnosticsSchema,
    cohortTable = cohortTable,
    cohortIds = c(17492, 17692),
    cohortDefinitionSet = cohortDefinitionSet,
    generateInclusionStats = TRUE,
    createCohortTable = TRUE,
    inclusionStatisticsFolder = inclusionStatsFolder
  )
  
  executeDiagnostics(
    connectionDetails = connectionDetails,
    cdmDatabaseSchema = cdmDatabaseSchema,
    vocabularyDatabaseSchema = vocabularyDatabaseSchema,
    tempEmulationSchema = tempEmulationSchema,
    cohortDatabaseSchema = cohortDiagnosticsSchema,
    cohortTable = cohortTable,
    cohortIds = c(17492, 17692),
    cohortDefinitionSet = cohortDefinitionSet,
    inclusionStatisticsFolder = inclusionStatsFolder,
    exportFolder = file.path(folder, "export"),
    databaseId = "cdmv5",
    runInclusionStatistics = TRUE,
    runBreakdownIndexEvents = TRUE,
    runCohortCharacterization = TRUE,
    runTemporalCohortCharacterization = TRUE,
    runCohortOverlap = TRUE,
    runIncidenceRate = TRUE,
    runIncludedSourceConcepts = TRUE,
    runOrphanConcepts = TRUE,
    runTimeDistributions = TRUE,
    incremental = TRUE,
    incrementalFolder = file.path(folder, "incremental")
  )
  
  listOfZipFilesToUpload <-
    list.files(
      path = file.path(folder, "export"),
      pattern = ".zip",
      full.names = TRUE,
      recursive = TRUE
    )
  
  for (i in (1:length(listOfZipFilesToUpload))) {
    uploadResults(
      connectionDetails = connectionDetails,
      schema = resultsDatabaseSchema,
      zipFileName = listOfZipFilesToUpload[[i]]
    )
  }
  
  specifications <- getResultsDataModelSpecifications()
  connection <- DatabaseConnector::connect(connectionDetails = connectionDetails)
  with_dbc_connection(connection, {
    for (tableName in unique(specifications$tableName)) {
      primaryKey <- specifications %>%
        dplyr::filter(.data$tableName == !!tableName &
                        .data$primaryKey == "Yes") %>%
        dplyr::select(.data$fieldName) %>%
        dplyr::pull()

      if ("database_id" %in% primaryKey) {
        sql <-
          "SELECT COUNT(*) FROM @schema.@table_name WHERE database_id = '@database_id';"
        sql <- SqlRender::render(
          sql = sql,
          schema = resultsDatabaseSchema,
          table_name = tableName,
          database_id = "cdmv5"
        )
        databaseIdCount <- DatabaseConnector::querySql(connection, sql)[, 1]
        expect_true(databaseIdCount >= 0)
      }
    }
  })
})

test_that("Data removal works", {
  specifications <- getResultsDataModelSpecifications()

  connection <- DatabaseConnector::connect(connectionDetails = connectionDetails)
  with_dbc_connection(connection, {
    for (tableName in unique(specifications$tableName)) {
      primaryKey <- specifications %>%
        dplyr::filter(.data$tableName == !!tableName &
                        .data$primaryKey == "Yes") %>%
        dplyr::select(.data$fieldName) %>%
        dplyr::pull()

      if ("database_id" %in% primaryKey) {
        CohortDiagnostics:::deleteAllRecordsForDatabaseId(
          connection = connection,
          schema = resultsDatabaseSchema,
          tableName = tableName,
          databaseId = "cdmv5"
        )

        sql <- "SELECT COUNT(*) FROM @schema.@table_name WHERE database_id = '@database_id';"
        sql <- SqlRender::render(
          sql = sql,
          schema = resultsDatabaseSchema,
          table_name = tableName,
          database_id = "cdmv5"
        )
        databaseIdCount <-
          DatabaseConnector::querySql(connection, sql)[, 1]
        expect_true(databaseIdCount == 0)
      }
    }
  })
})

test_that("util functions", {
  expect_true(naToEmpty(NA) == "")
  expect_true(naToZero(NA) == 0)
})

