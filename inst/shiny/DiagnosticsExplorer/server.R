shiny::shinyServer(function(input, output, session) {

  # Reacive: targetCohortId
  targetCohortId <- shiny::reactive({
    return(cohort$cohortId[cohort$compoundName == input$targetCohort])
  })

  # ReaciveVal: cohortIds
  cohortIds <- reactiveVal(NULL)
  shiny::observeEvent(eventExpr = {
    list(
      input$cohorts_open,
      input$tabs
    )
  }, handlerExpr = {
    if (isFALSE(input$cohorts_open) || !is.null(input$tabs)) {
      selectedCohortIds <-
        cohort$cohortId[cohort$compoundName %in% input$cohorts]
      cohortIds(selectedCohortIds)
    }
  })

  # Reacive: comparatorCohortId
  comparatorCohortId <- shiny::reactive({
    return(cohort$cohortId[cohort$compoundName == input$comparatorCohort])
  })

  selectedConceptSets <- reactiveVal(NULL)
  shiny::observeEvent(eventExpr = {
    list(
      input$conceptSetsSelected_open,
      input$tabs
    )
  }, handlerExpr = {
    if (isFALSE(input$conceptSetsSelected_open) || !is.null(input$tabs)) {
      selectedConceptSets(input$conceptSetsSelected)
    }
  })

  # conceptSetIds ----
  conceptSetIds <- shiny::reactive(x = {
    conceptSetsFiltered <- conceptSets %>%
      dplyr::filter(.data$conceptSetName %in% selectedConceptSets()) %>%
      dplyr::filter(.data$cohortId %in% targetCohortId()) %>%
      dplyr::select(.data$conceptSetId) %>%
      dplyr::pull() %>%
      unique()
    return(conceptSetsFiltered)
  })

  timeIds <- reactiveVal(NULL)
  shiny::observeEvent(eventExpr = {
    list(
      input$timeIdChoices_open,
      input$tabs
    )
  }, handlerExpr = {
    if (exists("temporalCharacterizationTimeIdChoices") &&
      (isFALSE(input$timeIdChoices_open) ||
        !is.null(input$tabs))) {
      if (!is.null(temporalChoices)) {
        selectedTimeIds <- temporalCharacterizationTimeIdChoices %>%
          dplyr::filter(.data$temporalChoices %in% input$timeIdChoices) %>%
          dplyr::pull(.data$timeId)
        timeIds(selectedTimeIds)
      }
    }
  })

  ## ReactiveValue: selectedDatabaseIds ----
  selectedDatabaseIds <- reactiveVal(NULL)
  shiny::observeEvent(eventExpr = {
    list(input$databases_open)
  }, handlerExpr = {
    if (isFALSE(input$databases_open)) {
      selectedDatabaseIds(input$databases)
    }
  })

  shiny::observeEvent(eventExpr = {
    list(input$database_open)
  }, handlerExpr = {
    if (isFALSE(input$database_open)) {
      selectedDatabaseIds(input$database)
    }
  })

  shiny::observeEvent(eventExpr = {
    list(input$tabs)
  }, handlerExpr = {
    if (!is.null(input$tabs)) {
      if (input$tabs %in% c(
        "compareCohortCharacterization",
        "compareTemporalCharacterization",
        "temporalCharacterization",
        "databaseInformation"
      )) {
        selectedDatabaseIds(input$database)
      } else {
        selectedDatabaseIds(input$databases)
      }
    }
  })


  ## ReactiveValue: selectedTemporalTimeIds ----
  selectedTemporalTimeIds <- reactiveVal(NULL)
  shiny::observeEvent(eventExpr = {
    list(
      input$timeIdChoices_open,
      input$timeIdChoices,
      input$tabs
    )
  }, handlerExpr = {
    if (isFALSE(input$timeIdChoices_open) ||
      !is.null(input$tabs) & !is.null(temporalCharacterizationTimeIdChoices)) {
      selectedTemporalTimeIds(
        timeIds <- temporalCharacterizationTimeIdChoices %>%
          dplyr::filter(.data$temporalChoices %in% input$timeIdChoices) %>%
          dplyr::pull(.data$timeId) %>%
          unique() %>%
          sort()
      )
    }
  })

  cohortSubset <- shiny::reactive({
    return(cohort %>%
             dplyr::arrange(.data$cohortId))
  })

  shiny::observe({
    subset <- cohortSubset()$compoundName
    shinyWidgets::updatePickerInput(
      session = session,
      inputId = "targetCohort",
      choicesOpt = list(style = rep_len("color: black;", 999)),
      choices = subset
    )
  })

  shiny::observe({
    subset <- cohortSubset()$compoundName
    shinyWidgets::updatePickerInput(
      session = session,
      inputId = "cohorts",
      choicesOpt = list(style = rep_len("color: black;", 999)),
      choices = subset,
      selected = c(subset[1], subset[2])
    )
  })

  shiny::observe({
    if (input$tabs == "cohortCounts" |
      input$tabs == "cohortOverlap" |
      input$tabs == "incidenceRate" |
      input$tabs == "timeDistribution") {
      subset <- input$cohorts
    } else {
      subset <- input$targetCohort
    }

    shinyWidgets::updatePickerInput(
      session = session,
      inputId = paste0("targetCohort", input$tabs),
      choicesOpt = list(style = rep_len("color: black;", 999)),
      choices = subset,
      selected = subset
    )
  })

  shiny::observe({
    shinyWidgets::updatePickerInput(
      session = session,
      inputId = paste0("database", input$tabs),
      choicesOpt = list(style = rep_len("color: black;", 999)),
      choices = selectedDatabaseIds(),
      selected = selectedDatabaseIds()
    )
  })

  shiny::observe({
    subset <- cohortSubset()$compoundName
    shinyWidgets::updatePickerInput(
      session = session,
      inputId = "comparatorCohort",
      choicesOpt = list(style = rep_len("color: black;", 999)),
      choices = subset,
      selected = subset[2]
    )
  })

  cohortDefinitionTableData <- shiny::reactive(x = {
    data <- cohortSubset() %>%
      dplyr::select(cohort = .data$shortName, .data$cohortId, .data$cohortName)
    return(data)
  })

  # Cohort Definition -----
  output$cohortDefinitionTable <-
    reactable::renderReactable(expr = {
      data <- cohortDefinitionTableData() %>%
        dplyr::mutate(cohortId = as.character(.data$cohortId))

      validate(need(hasData(data), "There is no data for this cohort."))
      keyColumns <- c("cohort", "cohortId", "cohortName")
      dataColumns <- c()

      getDisplayTableSimple(
        data = data,
        keyColumns = keyColumns,
        dataColumns = dataColumns,
        selection = "single"
      )
    })

  ## selectedCohortDefinitionRow -----
  selectedCohortDefinitionRow <- reactive({
    idx <- reactable::getReactableState("cohortDefinitionTable", "selected")
    if (is.null(idx)) {
      return(NULL)
    } else {
      subset <- cohortSubset()
      if (nrow(subset) == 0) {
        return(NULL)
      }
      row <- subset[idx[1],]
      return(row)
    }
  })

  # Orphan concepts table --------------------
  orphanConceptsDataReactive <- shiny::reactive(x = {
    validate(need(length(targetCohortId()) > 0, "No cohorts chosen"))
    data <- getOrphanConceptResult(
      dataSource = dataSource,
      cohortId = targetCohortId(),
      databaseIds = selectedDatabaseIds()
    )
    if (!hasData(data)) {
      return(NULL)
    }
    data <- data %>%
      dplyr::arrange(dplyr::desc(.data$conceptCount))
    return(data)
  })

  output$orphanConceptsTable <- reactable::renderReactable(expr = {
    data <- orphanConceptsDataReactive()
    validate(need(hasData(data), "There is no data for the selected combination."))

    if (hasData(selectedConceptSets())) {
      if (!is.null(selectedConceptSets())) {
        if (length(conceptSetIds()) > 0) {
          data <- data %>%
            dplyr::filter(.data$conceptSetId %in% conceptSetIds())
        } else {
          data <- data[0,]
        }
      }
    }

    if (input$orphanConceptsType == "Standard Only") {
      data <- data %>%
        dplyr::filter(.data$standardConcept == "S")
    } else if (input$orphanConceptsType == "Non Standard Only") {
      data <- data %>%
        dplyr::filter(is.na(.data$standardConcept) |
                        (
                          !is.na(.data$standardConcept) && .data$standardConcept != "S"
                        ))
    }

    validate(need(hasData(data), "There is no data for the selected combination."))

    data <- data %>%
      dplyr::select(
        .data$databaseId,
        .data$cohortId,
        .data$conceptId,
        .data$conceptSubjects,
        .data$conceptCount
      ) %>%
      dplyr::group_by(
        .data$databaseId,
        .data$cohortId,
        .data$conceptId
      ) %>%
      dplyr::summarise(
        conceptSubjects = sum(.data$conceptSubjects),
        conceptCount = sum(.data$conceptCount),
        .groups = "keep"
      ) %>%
      dplyr::ungroup() %>%
      dplyr::arrange(
        .data$databaseId,
        .data$cohortId
      ) %>%
      dplyr::inner_join(
        data %>%
          dplyr::select(
            .data$conceptId,
            .data$databaseId,
            .data$cohortId,
            .data$conceptName,
            .data$vocabularyId,
            .data$conceptCode
          ),
        by = c("databaseId", "cohortId", "conceptId")
      ) %>%
      dplyr::rename(
        persons = .data$conceptSubjects,
        records = .data$conceptCount
      ) %>%
      dplyr::arrange(dplyr::desc(abs(dplyr::across(
        c("records", "persons")
      ))))

    keyColumnFields <-
      c("conceptId", "conceptName", "vocabularyId", "conceptCode")
    if (input$orphanConceptsColumFilterType == "Persons") {
      dataColumnFields <- c("persons")
      countLocation <- 1
    } else if (input$orphanConceptsColumFilterType == "Records") {
      dataColumnFields <- c("records")
      countLocation <- 1
    } else {
      dataColumnFields <- c("persons", "records")
      countLocation <- 2
    }
    countsForHeader <-
      getDisplayTableHeaderCount(
        dataSource = dataSource,
        databaseIds = data$databaseId %>% unique(),
        cohortIds = data$cohortId %>% unique(),
        source = "cohort",
        fields = input$orphanConceptsColumFilterType
      )

    maxCountValue <-
      getMaxValueForStringMatchedColumnsInDataFrame(
        data = data,
        string = dataColumnFields
      )

    showDataAsPercent <- FALSE
    ## showDataAsPercent set based on UI selection - proportion

    displayTable <- getDisplayTableGroupedByDatabaseId(
      data = data,
      cohort = cohort,
      database = database,
      headerCount = countsForHeader,
      keyColumns = keyColumnFields,
      countLocation = countLocation,
      dataColumns = dataColumnFields,
      maxCount = maxCountValue,
      showDataAsPercent = showDataAsPercent,
      sort = TRUE
    )
    return(displayTable)
  })

  # Characterization (Shared across) -------------------------------------------------
  ## Reactive objects ----
  ### getConceptSetNameForFilter ----
  getConceptSetNameForFilter <- shiny::reactive(x = {
    if (!hasData(targetCohortId()) || !hasData(selectedDatabaseIds())) {
      return(NULL)
    }

    jsonExpression <- cohortSubset() %>%
      dplyr::filter(.data$cohortId == targetCohortId()) %>%
      dplyr::select(.data$json)
    jsonExpression <-
      RJSONIO::fromJSON(jsonExpression$json, digits = 23)
    expression <-
      getConceptSetDetailsFromCohortDefinition(cohortDefinitionExpression = jsonExpression)
    if (is.null(expression)) {
      return(NULL)
    }

    expression <- expression$conceptSetExpression %>%
      dplyr::select(.data$name)
    return(expression)
  })


  ## characterizationOutputForCharacterizationMenu ----
  characterizationOutputForCharacterizationMenu <-
    shiny::reactive(x = {
      progress <- shiny::Progress$new()
      on.exit(progress$close())
      progress$set(
        message = paste0(
          "Retrieving characterization output for cohort id ",
          targetCohortId(),
          " cohorts and ",
          length(selectedDatabaseIds()),
          " data sources."
        ),
        value = 0
      )
      data <- getCharacterizationOutput(
        dataSource = dataSource,
        cohortIds = targetCohortId(),
        databaseIds = selectedDatabaseIds(),
        temporalCovariateValueDist = FALSE
      )
      return(data)
    })

  ## characterizationOutputForTemporalCharacterizationMenu ----
  characterizationOutputForTemporalCharacterizationMenu <-
    shiny::reactive(x = {
      progress <- shiny::Progress$new()
      on.exit(progress$close())
      progress$set(
        message = paste0(
          "Retrieving characterization output for target cohort id ",
          targetCohortId(),
          " from ",
          input$database,
          "."
        ),
        value = 0
      )

      if (input$database %in% c(selectedDatabaseIds())) {
        data <- characterizationOutputForCharacterizationMenu()
        if (hasData(data$covariateValue)) {
          data$covariateValue <- data$covariateValue %>%
            dplyr::filter(.data$databaseId %in% c(input$database))
        }
        if (hasData(data$covariateValueDist)) {
          data$covariateValueDist <- data$covariateValueDist %>%
            dplyr::filter(.data$databaseId %in% c(input$database))
        }
      } else {
        data <- getCharacterizationOutput(
          dataSource = dataSource,
          cohortIds = targetCohortId(),
          databaseIds = input$database,
          temporalCovariateValueDist = FALSE
        )
      }
      return(data)
    })

  ## characterizationOutputForCompareCharacterizationMenu ----
  characterizationOutputForCompareCharacterizationMenu <-
    shiny::reactive(x = {
      dataTarget <-
        characterizationOutputForTemporalCharacterizationMenu()
      if (!hasData(dataTarget)) {
        return(NULL)
      }

      progress <- shiny::Progress$new()
      on.exit(progress$close())
      progress$set(
        message = paste0(
          "Retrieving characterization output for comparator cohort id ",
          comparatorCohortId(),
          " from ",
          input$database,
          "."
        ),
        value = 0
      )
      dataComparator <- getCharacterizationOutput(
        dataSource = dataSource,
        cohortIds = c(comparatorCohortId()),
        databaseIds = input$database,
        temporalCovariateValueDist = FALSE
      )
      if (!hasData(dataComparator)) {
        return(NULL)
      }
      data <- NULL
      data$covariateValue <-
        dplyr::bind_rows(
          dataTarget$covariateValue,
          dataComparator$covariateValue
        )
      if (!hasData(data$covariateValue)) {
        data$covariateValue <- NULL
      }
      data$covariateValueDist <-
        dplyr::bind_rows(
          dataTarget$covariateValueDist,
          dataComparator$covariateValueDist
        )
      if (!hasData(data$covariateValueDist)) {
        data$covariateValueDist <- NULL
      }
      return(data)
    })

  shiny::observe({
      subset <- getConceptSetNameForFilter()$name %>%
        sort() %>%
        unique()
      shinyWidgets::updatePickerInput(
        session = session,
        inputId = "conceptSetsSelected",
        choicesOpt = list(style = rep_len("color: black;", 999)),
        choices = subset
      )
    })

  getDatabaseInformation <- shiny::reactive(x = {
    return(database)
  })

  getFilteredMetadataInformation <- shiny::reactive(x = {
    data <- getExecutionMetadata(dataSource = dataSource)
    if (!hasData(data)) {
      return(NULL)
    }
    data <- data %>%
      dplyr::filter(.data$databaseId == selectedDatabaseIds())
    return(data)
  })

  # Output: databaseInformationTable ------------------------
  output$databaseInformationTable <- reactable::renderReactable(expr = {
    if (!input$tabs == "databaseInformation") {
      return(NULL)
    }

    data <- getDatabaseInformation()
    validate(need(
      all(!is.null(data), nrow(data) > 0),
      "No data available for selected combination."
    ))

    if (!"vocabularyVersionCdm" %in% colnames(data)) {
      data$vocabularyVersionCdm <- "Not in data"
    }
    if (!"vocabularyVersion" %in% colnames(data)) {
      data$vocabularyVersion <- "Not in data"
    }

    keyColumns <- intersect(
      colnames(data),
      c(
        "databaseId",
        "databaseName",
        "vocabularyVersionCdm",
        "vocabularyVersion",
        "description",
        "startTime",
        "runTime",
        "runTimeUnits",
        "sourceReleaseDate",
        "cdmVersion",
        "cdmReleaseDate",
        "observationPeriodMinDate",
        "observationPeriodMaxDate"
      )
    )

    dataColumns <- c(
      "personsInDatasource",
      "recordsInDatasource",
      "personDaysInDatasource"
    )

    getDisplayTableSimple(
      data = data,
      keyColumns = keyColumns,
      dataColumns = dataColumns
    )
  })

  output$metadataInfoTitle <- shiny::renderUI(expr = {
    data <- getFilteredMetadataInformation()

    if (!hasData(data)) {
      return(NULL)
    }
    tags$p(paste(
      "Run on ",
      data$databaseId,
      "on ",
      data$startTime,
      " for ",
      data$runTime,
      " ",
      data$runTimeUnits
    ))
  })

  output$metadataInfoDetailsText <- shiny::renderUI(expr = {
    data <- getFilteredMetadataInformation()
    if (!hasData(data)) {
      return(NULL)
    }
    tags$table(tags$tr(tags$td(
      paste(
        "Ran for ",
        data$runTime,
        data$runTimeUnits,
        "on ",
        data$currentPackage,
        "(",
        data$currentPackageVersion,
        ")"
      )
    )))
  })

  ## output: packageDependencySnapShotTable----
  output$packageDependencySnapShotTable <-
    reactable::renderReactable(expr = {
      data <- getFilteredMetadataInformation()
      if (!hasData(data)) {
        return(NULL)
      }
      data <- data %>%
        dplyr::pull(.data$packageDependencySnapShotJson)

      data <- dplyr::as_tibble(RJSONIO::fromJSON(
        content = data,
        digits = 23
      ))
      keyColumns <- colnames(data)
      getDisplayTableSimple(
        data = data,
        keyColumns = keyColumns,
        dataColumns = c(),
        pageSize = 10
      )
    })

  ## output: argumentsAtDiagnosticsInitiationJson----
  output$argumentsAtDiagnosticsInitiationJson <-
    shiny::renderText(expr = {
      data <- getFilteredMetadataInformation()
      if (!hasData(data)) {
        return(NULL)
      }
      data <- data %>%
        dplyr::pull(.data$argumentsAtDiagnosticsInitiationJson) %>%
        RJSONIO::fromJSON(digits = 23) %>%
        RJSONIO::toJSON(
          digits = 23,
          pretty = TRUE
        )
      return(data)
    })

  ## cohortCharacterizationDataFiltered ----
  cohortCharacterizationDataFiltered <- shiny::reactive(x = {
    if (!input$tabs %in% c("cohortCharacterization")) {
      return(NULL)
    }
    validate(need(length(selectedDatabaseIds()) > 0, "Atleast one data source must be selected"))
    validate(need(length(targetCohortId()) == 1, "One target cohort must be selected"))

    data <-
      characterizationOutputForCharacterizationMenu()
    if (!hasData(data)) {
      return(NULL)
    }
    data <- data$covariateValue
    if (!hasData(data)) {
      return(NULL)
    }

    data <- data %>%
      dplyr::filter(.data$analysisId %in% analysisIdInCohortCharacterization) %>%
      dplyr::filter(.data$timeId %in% c(characterizationTimeIdChoices$timeId %>% unique())) %>%
      dplyr::filter(.data$cohortId %in% c(targetCohortId())) %>%
      dplyr::filter(.data$databaseId %in% c(selectedDatabaseIds()))

    if (input$charType == "Raw") {
      if (input$characterizationProportionOrContinuous == "Proportion") {
        data <- data %>%
          dplyr::filter(.data$isBinary == "Y")
      } else if (input$characterizationProportionOrContinuous == "Continuous") {
        data <- data %>%
          dplyr::filter(.data$isBinary == "N")
      }
    }

    if (input$characterizationProportionOrContinuous == "Proportion") {
      data <- data %>%
        dplyr::filter(.data$isBinary == "Y")
    } else if (input$characterizationProportionOrContinuous == "Continuous") {
      data <- data %>%
        dplyr::filter(.data$isBinary == "N")
    }

    data <- data %>%
      dplyr::filter(.data$analysisName %in% characterizationAnalysisNameFilter())

    data <- data %>%
      dplyr::filter(.data$domainId %in% characterizationDomainIdFilter())

    if (hasData(selectedConceptSets())) {
      if (hasData(getResolvedAndMappedConceptIdsForFilters())) {
        data <- data %>%
          dplyr::filter(.data$conceptId %in% getResolvedAndMappedConceptIdsForFilters())
      }
    }
    if (!hasData(data)) {
      return(NULL)
    }
    return(data)
  })

  ## cohortCharacterizationPrettyTable ----
  cohortCharacterizationPrettyTable <- shiny::reactive(x = {
    if (!input$tabs %in% c("cohortCharacterization")) {
      return(NULL)
    }
    validate(need(length(selectedDatabaseIds()) > 0, "Atleast one data source must be selected"))
    validate(need(length(targetCohortId()) == 1, "One target cohort must be selected"))
    data <-
      characterizationOutputForCharacterizationMenu()
    if (!hasData(data)) {
      return(NULL)
    }
    data <- data$covariateValue
    if (!hasData(data)) {
      return(NULL)
    }

    data <- data %>%
      dplyr::filter(.data$analysisId %in% analysisIdInCohortCharacterization) %>%
      dplyr::filter(.data$timeId %in% c(characterizationTimeIdChoices$timeId %>% unique(), NA)) %>%
      dplyr::filter(.data$cohortId %in% c(targetCohortId())) %>%
      dplyr::filter(.data$databaseId %in% c(selectedDatabaseIds()))
    if (!hasData(data)) {
      return(NULL)
    }

    showDataAsPercent <-
      TRUE ## showDataAsPercent set based on UI selection - proportion)

    if (showDataAsPercent) {
      data <- data %>%
        dplyr::select(
          .data$cohortId,
          .data$databaseId,
          .data$analysisId,
          .data$covariateId,
          .data$covariateName,
          .data$mean
        ) %>%
        dplyr::rename(sumValue = .data$mean)
    } else {
      data <- data %>%
        dplyr::select(
          .data$cohortId,
          .data$databaseId,
          .data$analysisId,
          .data$covariateId,
          .data$covariateName,
          .data$sumValue
        )
    }

    table <- data %>%
      prepareTable1(
        prettyTable1Specifications = prettyTable1Specifications,
        cohort = cohort
      )
    if (!hasData(table)) {
      return(NULL)
    }
    keyColumnFields <- c("characteristic")
    dataColumnFields <- intersect(
      x = colnames(table),
      y = cohort$shortName
    )


    countLocation <- 1
    countsForHeader <-
      getDisplayTableHeaderCount(
        dataSource = dataSource,
        databaseIds = selectedDatabaseIds(),
        cohortIds = targetCohortId(),
        source = "cohort",
        fields = "Persons"
      )
    maxCountValue <-
      getMaxValueForStringMatchedColumnsInDataFrame(
        data = table,
        string = dataColumnFields
      )
    displayTable <- getDisplayTableGroupedByDatabaseId(
      data = table,
      cohort = cohort,
      database = database,
      headerCount = countsForHeader,
      keyColumns = keyColumnFields,
      countLocation = countLocation,
      dataColumns = dataColumnFields,
      maxCount = maxCountValue,
      showDataAsPercent = showDataAsPercent,
      sort = FALSE,
      pageSize = 100
    )
    return(displayTable)
  })

  ## cohortCharacterizationRawTable ----
  cohortCharacterizationRawTable <- shiny::reactive(x = {
    data <- cohortCharacterizationDataFiltered()
    if (!hasData(data)) {
      return(NULL)
    }
    progress <- shiny::Progress$new()
    on.exit(progress$close())
    progress$set(
      message = "Post processing: Rendering table",
      value = 0
    )
    data <- data %>%
      dplyr::select(
        .data$covariateName,
        .data$analysisName,
        .data$startDay,
        .data$endDay,
        .data$conceptId,
        .data$mean,
        .data$sd,
        .data$cohortId,
        .data$databaseId,
        .data$temporalChoices
      )

    keyColumnFields <-
      c("covariateName", "analysisName", "temporalChoices", "conceptId")

    showDataAsPercent <- FALSE
    if (input$characterizationColumnFilters == "Mean and Standard Deviation") {
      dataColumnFields <- c("mean", "sd")
    } else {
      dataColumnFields <- c("mean")
      if (input$characterizationProportionOrContinuous == "Proportion") {
        showDataAsPercent <- TRUE
      }
    }
    countLocation <- 1

    countsForHeader <-
      getDisplayTableHeaderCount(
        dataSource = dataSource,
        databaseIds = selectedDatabaseIds(),
        cohortIds = targetCohortId(),
        source = "cohort",
        fields = "Persons"
      )

    maxCountValue <-
      getMaxValueForStringMatchedColumnsInDataFrame(
        data = data,
        string = dataColumnFields
      )

    getDisplayTableGroupedByDatabaseId(
      data = data,
      cohort = cohort,
      database = database,
      headerCount = countsForHeader,
      keyColumns = keyColumnFields,
      countLocation = countLocation,
      dataColumns = dataColumnFields,
      maxCount = maxCountValue,
      showDataAsPercent = showDataAsPercent,
      sort = TRUE,
      pageSize = 100
    )
  })

  ## Output: characterizationTable ----
  output$characterizationTable <- reactable::renderReactable(expr = {
    if (input$charType == "Pretty") {
      data <- cohortCharacterizationPrettyTable()
      validate(need(hasData(data), "No data for selected combination"))
      return(data)
    } else {
      data <- cohortCharacterizationRawTable()
      validate(need(hasData(data), "No data for selected combination"))
      return(data)
    }
  })

  # Temporal characterization ------------
  ## ReactiveVal: temporalCharacterizationAnalysisNameFilter ----
  temporalCharacterizationAnalysisNameFilter <- reactiveVal(NULL)
  shiny::observeEvent(eventExpr = {
    list(
      input$temporalCharacterizationAnalysisNameFilter_open,
      input$tabs
    )
  }, handlerExpr = {
    if (isFALSE(input$temporalCharacterizationAnalysisNameFilter_open) ||
      !is.null(input$tabs)) {
      temporalCharacterizationAnalysisNameFilter(input$temporalCharacterizationAnalysisNameFilter)
    }
  })
  ### temporalCharacterizationAnalysisNameFilter ----
  shiny::observe({
    temporalCharacterizationAnalysisOptionsUniverse <- NULL
    temporalCharcterizationAnalysisOptionsSelected <- NULL

    if (hasData(temporalAnalysisRef)) {
      temporalCharacterizationAnalysisOptionsUniverse <-
        analysisNameOptions
      temporalCharcterizationAnalysisOptionsSelected <-
        temporalAnalysisRef %>%
          dplyr::filter(.data$analysisId %in% analysisIdInTemporalCharacterization) %>%
          dplyr::pull(.data$analysisName) %>%
          unique()
    }

    shinyWidgets::updatePickerInput(
      session = session,
      inputId = "temporalCharacterizationAnalysisNameFilter",
      choicesOpt = list(style = rep_len("color: black;", 999)),
      choices = temporalCharacterizationAnalysisOptionsUniverse,
      selected = temporalCharcterizationAnalysisOptionsSelected
    )
  })

  ## ReactiveVal: temporalCharacterizationDomainIdFilter ----
  temporalcharacterizationDomainIdFilter <- reactiveVal(NULL)
  shiny::observeEvent(eventExpr = {
    list(
      input$temporalcharacterizationDomainIdFilter_open,
      input$tabs
    )
  }, handlerExpr = {
    if (isFALSE(input$temporalcharacterizationDomainIdFilter_open) ||
      !is.null(input$tabs)) {
      temporalcharacterizationDomainIdFilter(input$temporalcharacterizationDomainIdFilter)
    }
  })

  ### temporalcharacterizationDomainIdFilter ----
  shiny::observe({
    temporalCharacterizationDomainOptionsUniverse <- NULL
    temporalCharcterizationDomainOptionsSelected <- NULL

    if (hasData(temporalAnalysisRef)) {
      temporalCharacterizationDomainOptionsUniverse <-
        domainIdOptions
      temporalCharcterizationDomainOptionsSelected <-
        temporalAnalysisRef %>%
          dplyr::filter(.data$analysisId %in% analysisIdInTemporalCharacterization) %>%
          dplyr::pull(.data$domainId) %>%
          unique()
    }

    shinyWidgets::updatePickerInput(
      session = session,
      inputId = "temporalcharacterizationDomainIdFilter",
      choicesOpt = list(style = rep_len("color: black;", 999)),
      choices = temporalCharacterizationDomainOptionsUniverse,
      selected = temporalCharcterizationDomainOptionsSelected
    )
  })

  ## temporalCohortCharacterizationDataFiltered ------------
  temporalCohortCharacterizationDataFiltered <- shiny::reactive({
    if (!input$tabs %in% c("temporalCharacterization")) {
      return(NULL)
    }
    validate(need(length(input$database) == 1, "One data source must be selected"))
    validate(need(length(targetCohortId()) == 1, "One target cohort must be selected"))
    if (!hasData(selectedTemporalTimeIds())) {
      return(NULL)
    }
    data <-
      characterizationOutputForCharacterizationMenu()
    if (!hasData(data)) {
      return(NULL)
    }
    data <- data$covariateValue
    if (!hasData(data)) {
      return(NULL)
    }
    data <- data %>%
      dplyr::filter(.data$analysisId %in% analysisIdInTemporalCharacterization) %>%
      dplyr::filter(.data$timeId %in% selectedTemporalTimeIds()) %>%
      dplyr::filter(.data$cohortId %in% c(targetCohortId())) %>%
      dplyr::filter(.data$databaseId %in% c(input$database))

    if (input$temporalProportionOrContinuous == "Proportion") {
      data <- data %>%
        dplyr::filter(.data$isBinary == "Y")
    } else if (input$temporalProportionOrContinuous == "Continuous") {
      data <- data %>%
        dplyr::filter(.data$isBinary == "N")
    }

    data <- data %>%
      dplyr::filter(.data$analysisName %in% temporalCharacterizationAnalysisNameFilter()) %>%
      dplyr::filter(.data$domainId %in% temporalcharacterizationDomainIdFilter())

    if (hasData(selectedConceptSets())) {
      if (hasData(getResolvedAndMappedConceptIdsForFilters())) {
        data <- data %>%
          dplyr::filter(.data$conceptId %in% getResolvedAndMappedConceptIdsForFilters())
      }
    }
    if (!hasData(data)) {
      return(NULL)
    }
    return(data)
  })

  ## temporalCharacterizationRawTable ----
  temporalCharacterizationRawTable <- shiny::reactive(x = {
    data <- temporalCohortCharacterizationDataFiltered()
    validate(need(
      hasData(data),
      "No temporal characterization data"
    ))
    progress <- shiny::Progress$new()
    on.exit(progress$close())
    progress$set(
      message = "Post processing: Rendering table",
      value = 0
    )

    temporalChoices <- temporalCharacterizationTimeIdChoices %>%
      dplyr::filter(.data$timeId %in% c(data$timeId %>% unique())) %>%
      dplyr::pull(.data$temporalChoices) %>%
      unique()

    keyColumns <- c("covariateName", "analysisName", "conceptId")
    data <- data %>%
      dplyr::select(
        .data$covariateName,
        .data$analysisName,
        .data$temporalChoices,
        .data$conceptId,
        .data$mean,
        .data$sd
      ) %>%
      tidyr::pivot_wider(
        id_cols = dplyr::all_of(keyColumns),
        names_from = "temporalChoices",
        values_from = "mean",
        names_sep = "_"
      ) %>%
      dplyr::relocate(dplyr::all_of(c(keyColumns, temporalChoices))) %>%
      dplyr::arrange(dplyr::desc(dplyr::across(dplyr::starts_with("T ("))))

    if (any(stringr::str_detect(
      string = colnames(data),
      pattern = stringr::fixed("T (0")
    ))) {
      data <- data %>%
        dplyr::arrange(dplyr::desc(dplyr::across(dplyr::starts_with("T (0"))))
    }

    dataColumns <- c(temporalChoices)

    showDataAsPercent <- FALSE
    if (input$temporalProportionOrContinuous == "Proportion") {
      showDataAsPercent <- TRUE
    }

    getDisplayTableSimple(
      data = data,
      keyColumns = keyColumns,
      dataColumns = dataColumns,
      showDataAsPercent = showDataAsPercent,
      pageSize = 100
    )
  })

  ## Output: temporalCharacterizationTable ------------------------
  output$temporalCharacterizationTable <-
    reactable::renderReactable(expr = {
      temporalCharacterizationRawTable()
    })

  # Compare cohort characterization --------------------------------------------
  ## ReactiveVal: compareCohortCharacterizationAnalysisNameFilter ----
  compareCohortCharacterizationAnalysisNameFilter <- reactiveVal(NULL)
  shiny::observeEvent(eventExpr = {
    list(
      input$compareCohortCharacterizationAnalysisNameFilter_open,
      input$tabs
    )
  }, handlerExpr = {
    if (isFALSE(input$compareCohortCharacterizationAnalysisNameFilter_open) ||
      !is.null(input$tabs)) {
      compareCohortCharacterizationAnalysisNameFilter(input$compareCohortCharacterizationAnalysisNameFilter)
    }
  })

  ### compareCohortCharacterizationAnalysisNameFilter -----
  shiny::observe({
    characterizationAnalysisOptionsUniverse <- NULL
    charcterizationAnalysisOptionsSelected <- NULL

    if (hasData(temporalAnalysisRef)) {
      characterizationAnalysisOptionsUniverse <- analysisNameOptions
      charcterizationAnalysisOptionsSelected <-
        temporalAnalysisRef %>%
          dplyr::filter(.data$analysisId %in% analysisIdInCohortCharacterization) %>%
          dplyr::pull(.data$analysisName) %>%
          unique()
    }

    shinyWidgets::updatePickerInput(
      session = session,
      inputId = "compareCohortCharacterizationAnalysisNameFilter",
      choicesOpt = list(style = rep_len("color: black;", 999)),
      choices = characterizationAnalysisOptionsUniverse,
      selected = charcterizationAnalysisOptionsSelected
    )
  })

  ## ReactiveVal: compareCohortcharacterizationDomainIdFilter ----
  compareCohortcharacterizationDomainIdFilter <- reactiveVal(NULL)
  shiny::observeEvent(eventExpr = {
    list(
      input$compareCohortcharacterizationDomainIdFilter_open,
      input$tabs
    )
  }, handlerExpr = {
    if (isFALSE(input$compareCohortcharacterizationDomainIdFilter_open) ||
      !is.null(input$tabs)) {
      compareCohortcharacterizationDomainIdFilter(input$compareCohortcharacterizationDomainIdFilter)
    }
  })
  ### compareCohortcharacterizationDomainIdFilter -----
  shiny::observe({
    characterizationDomainOptionsUniverse <- NULL
    charcterizationDomainOptionsSelected <- NULL

    if (hasData(temporalAnalysisRef)) {
      characterizationDomainOptionsUniverse <- domainIdOptions
      charcterizationDomainOptionsSelected <-
        temporalAnalysisRef %>%
          dplyr::filter(.data$analysisId %in% analysisIdInCohortCharacterization) %>%
          dplyr::pull(.data$domainId) %>%
          unique()
    }

    shinyWidgets::updatePickerInput(
      session = session,
      inputId = "compareCohortcharacterizationDomainIdFilter",
      choicesOpt = list(style = rep_len("color: black;", 999)),
      choices = characterizationDomainOptionsUniverse,
      selected = charcterizationDomainOptionsSelected
    )
  })

  ## compareCohortCharacterizationDataFiltered ------------
  compareCohortCharacterizationDataFiltered <- shiny::reactive({
    if (!input$tabs %in% c("compareCohortCharacterization")) {
      return(NULL)
    }
    validate(need(length(input$database) == 1, "One data source must be selected"))
    validate(need(length(targetCohortId()) == 1, "One target cohort must be selected"))
    validate(need(
      length(comparatorCohortId()) == 1,
      "One comparator cohort must be selected"
    ))
    validate(
      need(
        targetCohortId() != comparatorCohortId(),
        "Target and comparator cohorts cannot be the same"
      )
    )
    data <- characterizationOutputForCompareCharacterizationMenu()
    if (!hasData(data)) {
      return(NULL)
    }

    data <- data$covariateValue
    if (!hasData(data)) {
      return(NULL)
    }
    data <- data %>%
      dplyr::filter(.data$analysisId %in% analysisIdInCohortCharacterization) %>%
      dplyr::filter(.data$timeId %in% c(characterizationTimeIdChoices$timeId %>% unique(), NA)) %>%
      dplyr::filter(.data$cohortId %in% c(targetCohortId(), comparatorCohortId())) %>%
      dplyr::filter(.data$databaseId %in% c(input$database))

    if (input$charCompareType == "Raw") {
      if (input$compareCharacterizationProportionOrContinuous == "Proportion") {
        data <- data %>%
          dplyr::filter(.data$isBinary == "Y")
      } else if (input$compareCharacterizationProportionOrContinuous == "Continuous") {
        data <- data %>%
          dplyr::filter(.data$isBinary == "N")
      }
    }

    if (input$compareCharacterizationProportionOrContinuous == "Proportion") {
      data <- data %>%
        dplyr::filter(.data$isBinary == "Y")
    } else if (input$compareCharacterizationProportionOrContinuous == "Continuous") {
      data <- data %>%
        dplyr::filter(.data$isBinary == "N")
    }

    data <- data %>%
      dplyr::filter(.data$analysisName %in% compareCohortCharacterizationAnalysisNameFilter()) %>%
      dplyr::filter(.data$domainId %in% compareCohortcharacterizationDomainIdFilter())

    if (hasData(selectedConceptSets())) {
      if (hasData(getResolvedAndMappedConceptIdsForFilters())) {
        data <- data %>%
          dplyr::filter(.data$conceptId %in% getResolvedAndMappedConceptIdsForFilters())
      }
    }
    if (!hasData(data)) {
      return(NULL)
    }
    return(data)
  })

  ## compareCohortCharacterizationBalanceData ----------------------------------------
  compareCohortCharacterizationBalanceData <- shiny::reactive({
    if (!input$tabs %in% c("compareCohortCharacterization")) {
      return(NULL)
    }
    data <- compareCohortCharacterizationDataFiltered()
    if (!hasData(data)) {
      return(NULL)
    }

    covs1 <- data %>%
      dplyr::filter(.data$cohortId %in% c(targetCohortId()))
    if (!hasData(covs1)) {
      return(NULL)
    }
    covs2 <- data %>%
      dplyr::filter(.data$cohortId %in% c(comparatorCohortId()))
    if (!hasData(covs2)) {
      return(NULL)
    }

    balance <- compareCohortCharacteristics(covs1, covs2)
    return(balance)
  })

  ## compareCohortCharacterizationPrettyTable ----------------------------------------
  compareCohortCharacterizationPrettyTable <- shiny::reactive(x = {
    if (!input$charCompareType == "Pretty table") {
      return(NULL)
    }
    data <- compareCohortCharacterizationBalanceData()
    if (!hasData(data)) {
      return(NULL)
    }

    showDataAsPercent <- TRUE

    if (showDataAsPercent) {
      data1 <- data %>%
        dplyr::rename(
          "cohortId" = .data$cohortId1,
          "mean" = .data$mean1,
          "sumValue" = .data$sumValue1
        ) %>%
        dplyr::select(
          .data$cohortId,
          .data$databaseId,
          .data$analysisId,
          .data$covariateId,
          .data$covariateName,
          .data$mean
        ) %>%
        dplyr::rename(sumValue = .data$mean)

      data2 <- data %>%
        dplyr::rename(
          "cohortId" = .data$cohortId2,
          "mean" = .data$mean2,
          "sumValue" = .data$sumValue2
        ) %>%
        dplyr::select(
          .data$cohortId,
          .data$databaseId,
          .data$analysisId,
          .data$covariateId,
          .data$covariateName,
          .data$mean
        ) %>%
        dplyr::rename(sumValue = .data$mean)
    } else {
      data1 <- data %>%
        dplyr::rename(
          "cohortId" = .data$cohortId1,
          "mean" = .data$mean1,
          "sumValue" = .data$sumValue1
        ) %>%
        dplyr::select(
          .data$cohortId,
          .data$databaseId,
          .data$analysisId,
          .data$covariateId,
          .data$covariateName,
          .data$sumValue
        )
      data2 <- data %>%
        dplyr::rename(
          "cohortId" = .data$cohortId2,
          "mean" = .data$mean2,
          "sumValue" = .data$sumValue2
        ) %>%
        dplyr::select(
          .data$cohortId,
          .data$databaseId,
          .data$analysisId,
          .data$covariateId,
          .data$covariateName,
          .data$sumValue
        )
    }

    data1 <-
      prepareTable1(
        covariates = data1,
        prettyTable1Specifications = prettyTable1Specifications,
        cohort = cohort
      )

    data2 <-
      prepareTable1(
        covariates = data2,
        prettyTable1Specifications = prettyTable1Specifications,
        cohort = cohort
      )

    data <- data1 %>%
      dplyr::full_join(data2,
                       by = c(
                         "characteristic",
                         "sequence",
                         "databaseId"
                       )
      ) %>%
      dplyr::arrange(.data$databaseId, .data$sequence) %>%
      dplyr::select(-.data$databaseId)

    if (!hasData(data)) {
      return(NULL)
    }
    keyColumns <- c("characteristic")
    dataColumns <- intersect(
      x = colnames(data),
      y = cohort$shortName
    )

    table <- getDisplayTableSimple(
      data = data,
      keyColumns = keyColumns,
      dataColumns = dataColumns,
      showDataAsPercent = showDataAsPercent
    )
    return(table)
  })

  ## compareCohortCharacterizationRawTable ----------------------------------------
  compareCohortCharacterizationRawTable <- shiny::reactive(x = {
    if (!input$charCompareType == "Raw table") {
      return(NULL)
    }
    data <- compareCohortCharacterizationBalanceData()
    if (!hasData(data)) {
      return(NULL)
    }

    distinctTemporalChoices <- unique(temporalChoices$temporalChoices)
    sortedTemporalChoices <- data %>%
      dplyr::arrange(factor(.data$temporalChoices, levels = distinctTemporalChoices)) %>%
      dplyr::distinct(.data$temporalChoices) %>%
      dplyr::pull(.data$temporalChoices)

    data <- data %>%
      dplyr::arrange(factor(.data$temporalChoices, levels = sortedTemporalChoices))
    progress <- shiny::Progress$new()
    on.exit(progress$close())
    progress$set(
      message = "Post processing: Rendering table",
      value = 0
    )
    data <- data %>%
      dplyr::rename(
        "target" = mean1,
        "sdT" = sd1,
        "comparator" = mean2,
        "sdC" = sd2,
        "StdDiff" = absStdDiff
      )

    keyColumnFields <-
      c("covariateName", "analysisName", "conceptId")

    showDataAsPercent <- FALSE
    if (input$compareCharacterizationColumnFilters == "Mean and Standard Deviation") {
      dataColumnFields <-
        c(
          "target",
          "sdT",
          "comparator",
          "sdC",
          "StdDiff"
        )
    } else {
      dataColumnFields <- c("target", "comparator", "StdDiff")
      if (input$compareCharacterizationProportionOrContinuous == "Proportion") {
        showDataAsPercent <- TRUE
      }
    }
    countLocation <- 1

    maxCountValue <-
      getMaxValueForStringMatchedColumnsInDataFrame(
        data = data,
        string = dataColumnFields
      )

    getDisplayTableGroupedByDatabaseId(
      data = data,
      cohort = cohort,
      database = database,
      headerCount = NULL,
      keyColumns = keyColumnFields,
      countLocation = countLocation,
      dataColumns = dataColumnFields,
      maxCount = maxCountValue,
      showDataAsPercent = showDataAsPercent,
      excludedColumnFromPercentage = "StdDiff",
      sort = TRUE,
      isTemporal = TRUE,
      pageSize = 100
    )
  })

  ## output: compareCohortCharacterizationTable ----------------------------------------
  output$compareCohortCharacterizationTable <- reactable::renderReactable(expr = {
    if (input$charCompareType == "Pretty table") {
      data <- compareCohortCharacterizationPrettyTable()
      validate(need(hasData(data), "No data for selected combination"))
      return(data)
    } else if (input$charCompareType == "Raw table") {
      data <- compareCohortCharacterizationRawTable()
      validate(need(hasData(data), "No data for selected combination"))
      return(data)
    }
  })

  ## output: compareCohortCharacterizationBalancePlot ----------------------------------------
  output$compareCohortCharacterizationBalancePlot <-
    ggiraph::renderggiraph(expr = {
      if (!input$charCompareType == "Plot") {
        return(NULL)
      }
      data <- compareCohortCharacterizationBalanceData()
      validate(need(
        hasData(data),
        "No data available for selected combination."
      ))

      distinctTemporalChoices <- unique(temporalChoices$temporalChoices)
      data <- data %>%
        dplyr::arrange(factor(.data$temporalChoices, levels = distinctTemporalChoices)) %>%
        dplyr::mutate(temporalChoices = factor(.data$temporalChoices, levels = unique(.data$temporalChoices)))

      plot <-
        plotTemporalCompareStandardizedDifference(
          balance = data,
          shortNameRef = cohort,
          xLimitMin = 0,
          xLimitMax = 1,
          yLimitMin = 0,
          yLimitMax = 1
        )
      validate(need(
        !is.null(plot),
        "No plot available for selected combination."
      ))
      return(plot)
    })

  # Compare Temporal Characterization.-----------------------------------------
  ## ReactiveVal: temporalCompareAnalysisNameFilter ----
  temporalCompareAnalysisNameFilter <- reactiveVal(NULL)
  shiny::observeEvent(eventExpr = {
    list(
      input$temporalCompareAnalysisNameFilter_open,
      input$tabs
    )
  }, handlerExpr = {
    if (isFALSE(input$temporalCompareAnalysisNameFilter_open) ||
      !is.null(input$tabs)) {
      temporalCompareAnalysisNameFilter(input$temporalCompareAnalysisNameFilter)
    }
  })

  ### temporalCompareAnalysisNameFilter ----
  shiny::observe({
    temporalCharacterizationAnalysisOptionsUniverse <- NULL
    temporalCharcterizationAnalysisOptionsSelected <- NULL

    if (hasData(temporalAnalysisRef)) {
      temporalCharacterizationAnalysisOptionsUniverse <-
        analysisNameOptions
      temporalCharcterizationAnalysisOptionsSelected <-
        temporalAnalysisRef %>%
          dplyr::filter(.data$analysisId %in% analysisIdInTemporalCharacterization) %>%
          dplyr::pull(.data$analysisName) %>%
          unique()
    }

    shinyWidgets::updatePickerInput(
      session = session,
      inputId = "temporalCompareAnalysisNameFilter",
      choicesOpt = list(style = rep_len("color: black;", 999)),
      choices = temporalCharacterizationAnalysisOptionsUniverse,
      selected = temporalCharcterizationAnalysisOptionsSelected
    )
  })

  ## ReactiveVal: temporalCompareDomainNameFilter ----
  temporalCompareDomainNameFilter <- reactiveVal(NULL)
  shiny::observeEvent(eventExpr = {
    list(
      input$temporalCompareDomainNameFilter_open,
      input$tabs
    )
  }, handlerExpr = {
    if (isFALSE(input$temporalCompareDomainNameFilter_open) ||
      !is.null(input$tabs)) {
      temporalCompareDomainNameFilter(input$temporalCompareDomainNameFilter)
    }
  })
  ### temporalCompareDomainNameFilter ----
  shiny::observe({
    temporalCharacterizationDomainOptionsUniverse <- NULL
    temporalCharcterizationDomainOptionsSelected <- NULL

    if (hasData(temporalAnalysisRef)) {
      temporalCharacterizationDomainOptionsUniverse <-
        domainIdOptions
      temporalCharcterizationDomainOptionsSelected <-
        temporalAnalysisRef %>%
          dplyr::filter(.data$analysisId %in% analysisIdInTemporalCharacterization) %>%
          dplyr::pull(.data$domainId) %>%
          unique()
    }

    shinyWidgets::updatePickerInput(
      session = session,
      inputId = "temporalCompareDomainNameFilter",
      choicesOpt = list(style = rep_len("color: black;", 999)),
      choices = temporalCharacterizationDomainOptionsUniverse,
      selected = temporalCharcterizationDomainOptionsSelected
    )
  })


  ## compareTemporalCharacterizationDataFiltered ------------
  compareTemporalCharacterizationDataFiltered <- shiny::reactive({
    if (!input$tabs %in% c("compareTemporalCharacterization")) {
      return(NULL)
    }
    validate(need(length(input$database) == 1, "One data source must be selected"))
    validate(need(
      length(targetCohortId()) == 1,
      "One target cohort must be selected"
    ))
    validate(need(
      length(comparatorCohortId()) == 1,
      "One comparator cohort must be selected"
    ))
    validate(
      need(
        targetCohortId() != comparatorCohortId(),
        "Target and comparator cohorts cannot be the same"
      )
    )
    if (!hasData(selectedTemporalTimeIds())) {
      return(NULL)
    }
    data <-
      characterizationOutputForCompareTemporalCharacterizationMenu()
    if (!hasData(data)) {
      return(NULL)
    }
    data <- data$covariateValue
    if (!hasData(data)) {
      return(NULL)
    }
    data <- data %>%
      dplyr::filter(.data$analysisId %in% analysisIdInTemporalCharacterization) %>%
      dplyr::filter(.data$timeId %in% selectedTemporalTimeIds()) %>%
      dplyr::filter(.data$cohortId %in% c(targetCohortId(), comparatorCohortId())) %>%
      dplyr::filter(.data$databaseId %in% c(input$database))

    if (input$temporalCompareCharacterizationProportionOrContinuous == "Proportion") {
      data <- data %>%
        dplyr::filter(.data$isBinary == "Y")
    } else if (input$temporalCompareCharacterizationProportionOrContinuous == "Continuous") {
      data <- data %>%
        dplyr::filter(.data$isBinary == "N")
    }

    data <- data %>%
      dplyr::filter(.data$analysisName %in% temporalCompareAnalysisNameFilter()) %>%
      dplyr::filter(.data$domainId %in% temporalCompareDomainNameFilter())

    if (hasData(selectedConceptSets())) {
      if (hasData(getResolvedAndMappedConceptIdsForFilters())) {
        data <- data %>%
          dplyr::filter(.data$conceptId %in% getResolvedAndMappedConceptIdsForFilters())
      }
    }
    if (!hasData(data)) {
      return(NULL)
    }
    return(data)
  })


  ## compareCohortTemporalCharacterizationBalanceData ---------------------------
  compareCohortTemporalCharacterizationBalanceData <-
    shiny::reactive({
      if (!input$tabs %in% c("compareTemporalCharacterization")) {
        return(NULL)
      }
      data <- compareTemporalCharacterizationDataFiltered()
      if (!hasData(data)) {
        return(NULL)
      }
      covs1 <- data %>%
        dplyr::filter(.data$cohortId == targetCohortId())
      if (!hasData(covs1)) {
        return(NULL)
      }
      covs2 <- data %>%
        dplyr::filter(.data$cohortId %in% c(comparatorCohortId()))
      if (!hasData(covs2)) {
        return(NULL)
      }
      balance <-
        compareCohortCharacteristics(covs1, covs2)
      if (!hasData(balance)) {
        return(NULL)
      }
      return(balance)
    })


  ## compareCohortTemporalCharacterizationTable ---------------------------
  compareCohortTemporalCharacterizationTable <-
    shiny::reactive({
      if (!input$temporalCharacterizationType == "Raw table") {
        return(NULL)
      }
      data <- compareCohortTemporalCharacterizationBalanceData()
      validate(need(
        hasData(data),
        "No data available for selected combination."
      ))

      progress <- shiny::Progress$new()
      on.exit(progress$close())
      progress$set(
        message = "Post processing: Rendering table",
        value = 0
      )

      distinctTemporalChoices <- unique(temporalChoices$temporalChoices)
      sortedTemporalChoices <- data %>%
        dplyr::arrange(factor(.data$temporalChoices, levels = distinctTemporalChoices)) %>%
        dplyr::distinct(.data$temporalChoices) %>%
        dplyr::pull(.data$temporalChoices)

      data <- data %>%
        dplyr::rename(
          "target" = mean1,
          "sDTarget" = sd1,
          "comparator" = mean2,
          "sDComparator" = sd2,
          "stdDiff" = stdDiff
        ) %>%
        dplyr::arrange(factor(.data$temporalChoices, levels = sortedTemporalChoices))

      showDataAsPercent <- FALSE
      keyColumnFields <-
        c("covariateId", "covariateName", "analysisName")
      if (input$temporalCharacterizationTypeColumnFilter == "Mean and Standard Deviation") {
        dataColumnFields <-
          c(
            "target",
            "sDTarget",
            "comparator",
            "sDComparator",
            "stdDiff"
          )
      } else {
        dataColumnFields <- c("target", "comparator", "stdDiff")

        if (input$temporalCompareCharacterizationProportionOrContinuous == "Proportion") {
          showDataAsPercent <- TRUE
        }
      }

      maxCountValue <-
        getMaxValueForStringMatchedColumnsInDataFrame(
          data = data,
          string = dataColumnFields
        )

      table <- getDisplayTableGroupedByDatabaseId(
        data = data,
        cohort = cohort,
        database = database,
        headerCount = NULL,
        keyColumns = keyColumnFields,
        countLocation = 1,
        dataColumns = dataColumnFields,
        maxCount = maxCountValue,
        showDataAsPercent = showDataAsPercent,
        excludedColumnFromPercentage = "stdDiff",
        sort = TRUE,
        isTemporal = TRUE,
        pageSize = 100
      )
      return(table)
    })

  ## Output: temporalCharacterizationCompareTable ---------------------------
  output$temporalCharacterizationCompareTable <-
    reactable::renderReactable(expr = {
      data <- compareCohortTemporalCharacterizationTable()
      if (!hasData(data)) {
        return(NULL)
      }
      return(data)
    })

  ## Output: temporalCharacterizationComparePlot ---------------------------
  output$temporalCharacterizationComparePlot <- ggiraph::renderggiraph(expr = {
    if (!input$temporalCharacterizationType == "Plot") {
      return(NULL)
    }
    data <- compareCohortTemporalCharacterizationBalanceData()
    validate(need(
      hasData(data),
      "No data available for selected combination."
    ))
    validate(need(
      (nrow(data) - nrow(data[data$mean1 < 0.001,])) > 5 &&
        (nrow(data) - nrow(data[data$mean2 < 0.001,])) > 5,
      paste0("Values of the means are too low.")
    ))

    distinctTemporalChoices <- unique(temporalChoices$temporalChoices)
    data <- data %>%
      dplyr::arrange(factor(.data$temporalChoices, levels = distinctTemporalChoices)) %>%
      dplyr::mutate(temporalChoices = factor(.data$temporalChoices, levels = unique(.data$temporalChoices)))
    progress <- shiny::Progress$new()
    on.exit(progress$close())
    progress$set(
      message = "Plotting ",
      value = 0
    )
    plot <-
      plotTemporalCompareStandardizedDifference(
        balance = data,
        shortNameRef = cohort,
        xLimitMin = 0,
        xLimitMax = 1,
        yLimitMin = 0,
        yLimitMax = 1
      )
    return(plot)
  })

  # Login User ---------------------------------------------
  activeLoggedInUser <- reactiveVal(NULL)

  if (enableAnnotation &&
    exists("userCredentials") &&
    nrow(userCredentials) > 0) {
    shiny::observeEvent(
      eventExpr = input$annotationUserPopUp,
      handlerExpr = {
        shiny::showModal(
          shiny::modalDialog(
            title = "Annotate",
            easyClose = TRUE,
            size = "s",
            footer = tagList(
              shiny::actionButton(inputId = "login", label = "Login"),
              shiny::modalButton("Cancel")
            ),
            tags$div(
              shiny::textInput(
                inputId = "userName",
                label = "User Name",
                width = NULL,
                value = if (enableAuthorization) {
                  ""
                } else {
                  "annonymous"
                }
              ),
              if (enableAuthorization) {
                shiny::passwordInput(
                  inputId = "password",
                  label = "Local Password",
                  width = NULL
                )
              },
            )
          )
        )
      }
    )


    shiny::observeEvent(
      eventExpr = input$login,
      handlerExpr = {
        tryCatch(
          expr = {
            if (enableAuthorization == TRUE) {
              if (input$userName == "" || input$password == "") {
                activeLoggedInUser(NULL)
                shiny::showModal(
                  shiny::modalDialog(
                    title = "Error",
                    easyClose = TRUE,
                    size = "s",
                    fade = TRUE,
                    "Please enter both the fields"
                  )
                )
              }
              userCredentialsFiltered <- userCredentials %>%
                dplyr::filter(.data$userId == input$userName)
              if (nrow(userCredentialsFiltered) > 0) {
                passwordHash <-
                  digest::digest(input$password, algo = "sha512")
                if (passwordHash %in% userCredentialsFiltered$hashCode) {
                  activeLoggedInUser(input$userName)
                  shiny::removeModal()
                } else {
                  activeLoggedInUser(NULL)
                  shiny::showModal(
                    shiny::modalDialog(
                      title = "Error",
                      easyClose = TRUE,
                      size = "s",
                      fade = TRUE,
                      "Invalid User"
                    )
                  )
                }
              } else {
                activeLoggedInUser(NULL)
                shiny::showModal(
                  shiny::modalDialog(
                    title = "Error",
                    easyClose = TRUE,
                    size = "s",
                    fade = TRUE,
                    "Invalid User"
                  )
                )
              }
            } else {
              if (input$userName == "") {
                activeLoggedInUser(NULL)
                shiny::showModal(
                  shiny::modalDialog(
                    title = "Error",
                    easyClose = TRUE,
                    size = "s",
                    fade = TRUE,
                    "Please enter the user name."
                  )
                )
              } else {
                activeLoggedInUser(input$userName)
                shiny::removeModal()
              }
            }
          },
          error = function() {
            activeLoggedInUser(NULL)
          }
        )
      }
    )

    output$userNameLabel <- shiny::renderText({
      return(ifelse(
        is.null(activeLoggedInUser()),
        "",
        paste(
          as.character(icon("user-circle")),
          stringr::str_to_title(activeLoggedInUser())
        )
      ))
    })

    # Annotation Section ------------------------------------
    ## Annotation enabled ------
    output$postAnnotationEnabled <- shiny::reactive({
      return(!is.null(activeLoggedInUser()) & enableAnnotation)
    })
    shiny::outputOptions(
      x = output,
      name = "postAnnotationEnabled",
      suspendWhenHidden = FALSE
    )

    ## Retrieve Annotation ----------------
    reloadAnnotationSection <- reactiveVal(0)
    getAnnotationReactive <- shiny::reactive({
      reloadAnnotationSection()
      if (input$tabs == "cohortCounts" |
        input$tabs == "cohortOverlap" |
        input$tabs == "incidenceRate" |
        input$tabs == "timeDistribution") {
        selectedCohortIds <- cohort %>%
          dplyr::filter(.data$compoundName %in% c(input$cohorts)) %>% # many cohorts selected
          dplyr::pull(.data$cohortId)
      } else {
        selectedCohortIds <- cohort %>%
          dplyr::filter(.data$compoundName %in% c(input$targetCohort)) %>% # one cohort selected
          dplyr::pull(.data$cohortId)
      }
      results <- getAnnotationResult(
        dataSource = dataSource,
        diagnosticsId = input$tabs,
        cohortIds = selectedCohortIds,
        databaseIds = selectedDatabaseIds()
      )

      if (nrow(results$annotation) == 0) {
        return(NULL)
      }
      return(results)
    })


    ## renderedAnnotation ----
    renderedAnnotation <- shiny::reactiveVal()
    shiny::observeEvent(eventExpr = input$tabs, {
      if (!is.null(input$tabs)) {
        renderedAnnotation(callModule(
          markdownInput::moduleMarkdownInput,
          paste0("annotation", input$tabs)
        ))

        output[[paste0("output", input$tabs)]] <-
          reactable::renderReactable({
            results <- getAnnotationReactive()

            if (is.null(results)) {
              return(NULL)
            }
            data <- results$annotation
            for (i in 1:nrow(data)) {
              data[i,]$annotation <-
                markdown::renderMarkdown(text = data[i,]$annotation)
            }
            data <- data %>%
              dplyr::mutate(
                Annotation = paste0(
                  "<b>",
                  .data$createdBy,
                  "@",
                  getTimeFromInteger(.data$createdOn),
                  ":</b>",
                  .data$annotation
                )
              ) %>%
              dplyr::select(.data$annotationId, .data$Annotation)

            reactable::reactable(
              data,
              columns = list(
                annotationId = reactable::colDef(show = FALSE),
                Annotation = reactable::colDef(html = TRUE)
              ),
              details = function(index) {
                subTable <- results$annotationLink %>%
                  dplyr::filter(.data$annotationId == data[index,]$annotationId) %>%
                  dplyr::inner_join(cohort %>%
                                      dplyr::select(
                                        .data$cohortId,
                                        .data$cohortName
                                      ),
                                    by = "cohortId"
                  )
                distinctCohortName <- subTable %>%
                  dplyr::distinct(.data$cohortName)
                distinctDatabaseId <- subTable %>%
                  dplyr::distinct(.data$databaseId)

                htmltools::div(
                  style = "margin:0;padding:0;padding-left:50px;",
                  tags$p(
                    style = "margin:0;padding:0;",
                    "Related Cohorts: ",
                    tags$p(
                      style = "padding-left:30px;",
                      tags$pre(
                        paste(distinctCohortName$cohortName, collapse = "\n")
                      )
                    )
                  ),
                  tags$br(),
                  tags$p(
                    "Related Databses: ",
                    tags$p(
                      style = "padding-left:30px;",
                      tags$pre(
                        paste(distinctDatabaseId$databaseId, collapse = "\n")
                      )
                    )
                  )
                )
              }
            )
          })
      }
    })


    ## Post Annotation ----------------
    getParametersToPostAnnotation <- shiny::reactive({
      tempList <- list()
      tempList$diagnosticsId <- input$tabs

      # Annotation - cohort Ids
      if (!is.null(input[[paste0("cohort", input$tabs)]])) {
        selectedCohortIds <-
          cohort %>%
            dplyr::filter(.data$compoundName %in% input[[paste0("cohort", input$tabs)]]) %>%
            dplyr::pull(.data$cohortId)
        # cohortsConceptInDataSource should be the same as in menu cohort
      } else {
        selectedCohortIds <- input$targetCohort
      }
      tempList$cohortIds <- selectedCohortIds

      # Annotation - database Ids
      if (!is.null(input[[paste0("database", input$tabs)]])) {
        selectedDatabaseIds <- input[[paste0("database", input$tabs)]]
      } else {
        selectedDatabaseIds <- selectedDatabaseIds()
      }
      tempList$databaseIds <- selectedDatabaseIds
      return(tempList)
    })

    postAnnotationTabList <- reactiveVal(c())
    observeEvent(eventExpr = input[[paste0("postAnnotation", input$tabs)]], {
      if (!paste(toString(input[[paste0("postAnnotation", input$tabs)]]), input$tabs) %in% postAnnotationTabList()) {
        postAnnotationTabList(c(
          postAnnotationTabList(),
          paste(toString(input[[paste0("postAnnotation", input$tabs)]]), input$tabs)
        ))
      }
    })

    observeEvent(
      eventExpr = postAnnotationTabList(),
      handlerExpr = {
        parametersToPostAnnotation <- getParametersToPostAnnotation()
        annotation <-
          renderedAnnotation()() # ()() - This is to retrieve a function inside reactive
        if (!is.null(activeLoggedInUser())) {
          createdBy <- activeLoggedInUser()
        } else {
          createdBy <- "Unknown"
        }

        result <- postAnnotationResult(
          dataSource = dataSource,
          resultsDatabaseSchema = resultsDatabaseSchema,
          diagnosticsId = parametersToPostAnnotation$diagnosticsId,
          cohortIds = parametersToPostAnnotation$cohortIds,
          databaseIds = parametersToPostAnnotation$databaseIds,
          annotation = annotation,
          createdBy = createdBy,
          createdOn = getTimeAsInteger()
        )

        if (result) {
          # trigger reload
          reloadAnnotationSection(reloadAnnotationSection() + 1)
        }
      }
    )
  }
  # Infoboxes -------------------
  showInfoBox <- function(title, htmlFileName) {
    shiny::showModal(shiny::modalDialog(
      title = title,
      easyClose = TRUE,
      footer = NULL,
      size = "l",
      HTML(readChar(
        htmlFileName, file.info(htmlFileName)$size
      ))
    ))
  }

  shiny::observeEvent(input$cohortCountsInfo, {
    showInfoBox("Cohort Counts", "html/cohortCounts.html")
  })

  shiny::observeEvent(input$incidenceRateInfo, {
    showInfoBox("Incidence Rate", "html/incidenceRate.html")
  })

  shiny::observeEvent(input$timeDistributionInfo, {
    showInfoBox("Time Distributions", "html/timeDistribution.html")
  })

  shiny::observeEvent(input$conceptsInDataSourceInfo, {
    showInfoBox(
      "Concepts in data source",
      "html/conceptsInDataSource.html"
    )
  })

  shiny::observeEvent(input$orphanConceptsInfo, {
    showInfoBox("Orphan (Source) Concepts", "html/orphanConcepts.html")
  })

  shiny::observeEvent(input$conceptSetDiagnosticsInfo, {
    showInfoBox(
      "Concept Set Diagnostics",
      "html/conceptSetDiagnostics.html"
    )
  })

  shiny::observeEvent(input$inclusionRuleStatsInfo, {
    showInfoBox(
      "Inclusion Rule Statistics",
      "html/inclusionRuleStats.html"
    )
  })

  shiny::observeEvent(input$indexEventBreakdownInfo, {
    showInfoBox("Index Event Breakdown", "html/indexEventBreakdown.html")
  })

  shiny::observeEvent(input$visitContextInfo, {
    showInfoBox("Visit Context", "html/visitContext.html")
  })

  shiny::observeEvent(input$cohortCharacterizationInfo, {
    showInfoBox(
      "Cohort Characterization",
      "html/cohortCharacterization.html"
    )
  })

  shiny::observeEvent(input$temporalCharacterizationInfo, {
    showInfoBox(
      "Temporal Characterization",
      "html/temporalCharacterization.html"
    )
  })

  shiny::observeEvent(input$cohortOverlapInfo, {
    showInfoBox("Cohort Overlap", "html/cohortOverlap.html")
  })

  shiny::observeEvent(input$compareCohortCharacterizationInfo, {
    showInfoBox(
      "Compare Cohort Characteristics",
      "html/compareCohortCharacterization.html"
    )
  })

  # Cohort labels ---------------------------------------
  targetCohortCount <- shiny::reactive({
    targetCohortWithCount <-
      getResultsCohortCounts(
        dataSource = dataSource,
        cohortIds = targetCohortId(),
        databaseIds = selectedDatabaseIds()
      ) %>%
        dplyr::left_join(y = cohort, by = "cohortId") %>%
        dplyr::arrange(.data$cohortName)
    return(targetCohortWithCount)
  })

  targetCohortCountHtml <- shiny::reactive({
    targetCohortCount <- targetCohortCount()
    return(htmltools::withTags(div(
      h5(
        "Target: ",
        targetCohortCount$cohortName,
        " ( n = ",
        scales::comma(x = targetCohortCount$cohortSubjects),
        " )"
      )
    )))
  })

  selectedCohorts <- shiny::reactive({
    cohorts <- cohortSubset() %>%
      dplyr::filter(.data$cohortId %in% cohortIds()) %>%
      dplyr::arrange(.data$cohortId) %>%
      dplyr::select(.data$compoundName)
    return(apply(cohorts, 1, function(x) {
      tags$tr(lapply(x, tags$td))
    }))
  })

  selectedCohort <- shiny::reactive({
    return(input$targetCohort)
  })

  selectedComparatorCohort <- shiny::reactive({
    return(input$comparatorCohort)
  })

  output$conceptsInDataSourceSelectedCohort <-
    shiny::renderUI({
      selectedCohort()
    })
  output$orphanConceptsSelectedCohort <-
    shiny::renderUI({
      selectedCohort()
    })

  output$characterizationSelectedCohort <-
    shiny::renderUI({
      selectedCohort()
    })
  output$incidenceRateSelectedCohorts <-
    shiny::renderUI({
      selectedCohorts()
    })


  cohortCountsModule(id = "cohortCounts",
                     dataSource = dataSource,
                     cohortTable = cohort, # The injection of tables like this should be removed
                     databaseTable = database, # The injection of tables like this should be removed
                     selectedCohorts = selectedCohorts,
                     selectedDatabaseIds = selectedDatabaseIds,
                     cohortIds = cohortIds)


  cohortDefinitionsModule(id = "cohortDefinitions",
                          dataSource = dataSource,
                          cohortDefinitions = cohortSubset,
                          cohortTable = cohort, # The injection of tables like this should be removed
                          databaseTable = database, # The injection of tables like this should be removed
                          vocabularyDatabaseSchemas = vocabularyDatabaseSchemas)

  indexEventBreakdownModule("indexEvents",
                              dataSource = dataSource,
                            selectedCohort = selectedCohort,
                            targetCohortId = targetCohortId,
                            selectedDatabaseIds = selectedDatabaseIds)

  inclusionRulesModule(id = "inclusionRules",
                       dataSource = dataSource,
                       cohortTable = cohort,
                       databaseTable = database,
                       selectedCohort = selectedCohort,
                       targetCohortId = targetCohortId,
                       selectedDatabaseIds = selectedDatabaseIds)

  cohortOverlapModule(id = "cohortOverlap",
                      dataSource = dataSource,
                      selectedCohorts = selectedCohorts,
                      selectedDatabaseIds = selectedDatabaseIds,
                      targetCohortId = targetCohortId,
                      cohortIds = cohortIds,
                      cohortTable = cohort)

  characterizationModule(id = "characterization",
                         dataSource = dataSource,
                         selectedCohorts = selectedCohorts,
                         selectedDatabaseIds = selectedDatabaseIds,
                         targetCohortId = targetCohortId,
                         cohortSubset = cohortSubset,
                         temporalAnalysisRef = temporalAnalysisRef,
                         analysisNameOptions = analysisNameOptions,
                         analysisIdInCohortCharacterization = analysisIdInCohortCharacterization,
                         getResolvedAndMappedConceptIdsForFilters = getResolvedAndMappedConceptIdsForFilters,
                         selectedConceptSets = selectedConceptSets,
                         characterizationMenuOutput = characterizationOutputForCharacterizationMenu, # This name must be changed
                         characterizationTimeIdChoices = characterizationTimeIdChoices)


  temporalCharacterizationModule(id = "temporalCharacterization",
                                 dataSource = dataSource,
                                 selectedCohorts = selectedCohorts,
                                 selectedDatabaseIds = selectedDatabaseIds,
                                 targetCohortId = targetCohortId,
                                 temporalAnalysisRef = temporalAnalysisRef,
                                 analysisNameOptions = analysisNameOptions,
                                 selectedTemporalTimeIds = selectedTemporalTimeIds,
                                 getResolvedAndMappedConceptIdsForFilters = getResolvedAndMappedConceptIdsForFilters,
                                 selectedConceptSets = selectedConceptSets,
                                 analysisIdInTemporalCharacterization = analysisIdInTemporalCharacterization,
                                 domainIdOptions = domainIdOptions,
                                 temporalCharacterizationTimeIdChoices = temporalCharacterizationTimeIdChoices,
                                 characterizationOutputForCharacterizationMenu = characterizationOutputForCharacterizationMenu)

  compareCohortCharacterizationModule("compareCohortCharacterization",
                                      dataSource = dataSource,
                                      selectedCohort = selectedCohort,
                                      selectedDatabaseIds = selectedDatabaseIds,
                                      targetCohortId = targetCohortId,
                                      comparatorCohortId = comparatorCohortId,
                                      selectedComparatorCohort = selectedComparatorCohort,
                                      selectedConceptSets = selectedConceptSets,
                                      selectedTimeIds = shiny::reactive({c(characterizationTimeIdChoices$timeId %>% unique(), NA)}),
                                      characterizationOutputMenu = characterizationOutputForCompareCharacterizationMenu,
                                      getResolvedAndMappedConceptIdsForFilters = getResolvedAndMappedConceptIdsForFilters,
                                      cohortTable = cohort,
                                      databaseTable = database,
                                      temporalAnalysisRef = temporalAnalysisRef,
                                      analysisIdInCohortCharacterization = analysisIdInCohortCharacterization,
                                      analysisNameOptions = analysisNameOptions,
                                      domainIdOptions = domainIdOptions,
                                      characterizationTimeIdChoices = characterizationTimeIdChoices,
                                      temporalChoices = temporalChoices,
                                      prettyTable1Specifications = prettyTable1Specifications)

  compareCohortCharacterizationModule("compareTemporalCohortCharacterization",
                                      dataSource = dataSource,
                                      selectedCohort = selectedCohort,
                                      selectedDatabaseIds = selectedDatabaseIds,
                                      targetCohortId = targetCohortId,
                                      comparatorCohortId = comparatorCohortId,
                                      selectedComparatorCohort = selectedComparatorCohort,
                                      selectedConceptSets = selectedConceptSets,
                                      selectedTimeIds = selectedTemporalTimeIds,
                                      characterizationOutputMenu = characterizationOutputForCompareCharacterizationMenu,
                                      getResolvedAndMappedConceptIdsForFilters = getResolvedAndMappedConceptIdsForFilters,
                                      cohortTable = cohort,
                                      databaseTable = database,
                                      temporalAnalysisRef = temporalAnalysisRef,
                                      analysisIdInCohortCharacterization = analysisIdInCohortCharacterization,
                                      analysisNameOptions = analysisNameOptions,
                                      domainIdOptions = domainIdOptions,
                                      characterizationTimeIdChoices = characterizationTimeIdChoices,
                                      temporalChoices = temporalChoices,
                                      prettyTable1Specifications = prettyTable1Specifications)

  visitContextModule(id = "visitContext",
                     dataSource = dataSource,
                     selectedCohort = selectedCohort,
                     selectedDatabaseIds = selectedDatabaseIds,
                     targetCohortId = targetCohortId,
                     cohortTable = cohort,
                     databaseTable = database)

  conceptsInDataSourceModule(id = "conceptsInDataSource",
                             dataSource = dataSource,
                             selectedCohort = selectedCohort,
                             selectedDatabaseIds = selectedDatabaseIds,
                             targetCohortId = targetCohortId,
                             selectedConceptSets = selectedConceptSets,
                             getResolvedAndMappedConceptIdsForFilters = getResolvedAndMappedConceptIdsForFilters,
                             cohortTable = cohort,
                             databaseTable = database)

  incidenceRatesModule(id = "incidenceRates",
                       dataSource = dataSource,
                       selectedCohorts = selectedCohorts,
                       cohortIds = cohortIds,
                       selectedDatabaseIds = selectedDatabaseIds,
                       cohortTable = cohort)

  timeDistributionsModule(id = "timeDistributions",
                          dataSource = dataSource,
                          selectedCohorts = selectedCohorts,
                          cohortIds = cohortIds,
                          selectedDatabaseIds = selectedDatabaseIds,
                          cohortTable = cohort)

  databaseInformationModule(id = "databaseInformation",
                            dataSource = dataSource,
                            selectedDatabaseIds = selectedDatabaseIds,
                            databaseTable = database)
})
